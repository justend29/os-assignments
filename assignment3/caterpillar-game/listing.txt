#pragma once
/**
 * @file bullet.h
 * @author Justen Di Ruscio
 * @brief Declarations for bullets and bullet shooting
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>

#include <jd/task.h>
#include <jd/threadpool.h>

#include <caterpillar/user/player.h>

#define BULLET_HEIGHT 1
#define BULLET_WIDTH  1

typedef enum BulletType {
  b_Player,
  b_Caterpillar
} BulletType;

typedef struct Bullet {
  BulletType bulletType;
  pthread_mutex_t locationMutex;
  int row;
  int col;
} Bullet;

typedef struct RunShootBulletArg {
  Bullet *bullet;
  ListNode *shootNode;
  void* shooter;
} RunShootBulletArg;

/**
 * @brief Initializes a bullet. Sets errno on error
 *
 * @param b bullet to initialize
 * @param row row to start
 * @param col col to start
 * @param bType type of bullet
 * @return int errno
 */
int initBullet(Bullet* const b, const int row, const int col, const BulletType bType);

/**
 * @brief Completely deletes the bullet, shoot task, and bullet in shootNode. Erases it from the provided shooter's list. Sets errno on error
 *
 * @param shooter Player of Caterpillar
 * @param shootNode node in shot list of shooter
 * @param bullet bullet in shootNode
 * @return int errno
 */
int deleteBullet(void *const shooter, ListNode *const shootNode,
                 Bullet *const bullet);

/**
 * @brief Destroys the provided bullet
 *
 * @param b bullet
 * @return int errno
 */
int destroyBullet(Bullet* const b);

/**
 * @brief Shoots a bullet from the provided location. Sets errno on error
 *
 * @param row start row
 * @param col start column
 * @param bType type of bullet to shoot
 * @param shooter Player or Caterpillar to shoot bullet
 * @return int errno
 */
int shootBullet(const int row, const int col, const BulletType bType, void* const shooter);

/**
 * @brief Deletes the provided bullet task and the enclosed bullet. Used as a deleter.
 *
 * @param bulletTask Task of shot bullet to delete
 */
void deleteBulletTask(void* bulletTask);
#pragma once
/**
 * @file bullet_collisions.h
 * @author Justen Di Ruscio
 * @brief Contains utility functions to detect bullet collisions
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <stdbool.h>

#include <jd/list.h>

#include <caterpillar/caterpillars/caterpillar.h>
#include <caterpillar/user/player.h>
#include <caterpillar/bullets/bullet.h>

/**
 * @brief Detects if the provided bullet hit the provided caterpillar segment provided caterpillar segment without locking either. sets errno on error
 *
 * @param b bullet
 * @param seg caterpillar segment
 * @return true bullet hit caterpillar segment
 * @return false bullet didn't hit caterpillar segment
 */
bool hitCaterpillarSegment(const Bullet *const b,
                           const CaterpillarSegment *const seg);

/**
 * @brief Detects if the provided bullet hit any of the caterpillars in the provided list. Sets hitCaterpillar node to the hit caterpillar node upon a collision. sets errno on error
 *
 * @param bullet
 * @param runningCaterpillars list of caterpillars
 * @param hitCaterpillarNode set to the caterpillar node that the bullet hit
 * @return true bullet hit one of the caterpillars
 * @return false bullet hit no caterpillars
 */
bool hitCaterpillars(Bullet *const bullet,
                     List *const runningCaterpillars, ListNode** hitCaterpillarNode);

/**
 * @brief detects if any bullet shot by the player has hit the provided caterpillar. Sets hitBulletNode to the bullet node that hit the caterpillar. Sets errno on error
 *
 * @param caterpillar
 * @param hitBulletNode points to the bullet node that hit the caterpillar, if a collision occurred
 * @return true a collision occurred
 * @return false a collision didn't occur
 */
bool anyBulletHitCaterpillar(Caterpillar* const caterpillar, ListNode** hitBulletNode);

/**
 * @brief Detects if the provided bullet hit the provided player without locking either. sets errno on error
 *
 * @param bullet
 * @param player
 * @return true bullet hit player
 * @return false bullet didn't hit player
 */
bool hitPlayer(Bullet * const bullet, Player* const player);


/**
 * @brief Performs the same action as hitPlayer, but locks the player's locks
 *
 * @param bullet
 * @param player
 * @return true bullet hit player
 * @return false bullet didn't hit player
 */
bool hitPlayerLocked(Bullet * const bullet, Player* const player);

/**
 * @brief detects if any caterpillar bullet hit the player. Sets hitBulletNode to the bullet node that collided. Sets errno on error.
 *
 * @param player
 * @param shooter
 * @param hitBulletNode bullet node that hit the player
 * @return true a caterpillar bullet hit the player
 * @return false no bullet hit player
 */
bool anyBulletHitPlayer(Player* const player, Caterpillar** shooter, ListNode** hitBulletNode);
#pragma once
/**
 * @file collision_reactions.h
 * @author Justen Di Ruscio
 * @brief Contains declarations for actions to take when player/caterpillar get hit with bullet
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <jd/list.h>

#include <caterpillar/caterpillars/caterpillar.h>

/**
 * @brief Reacts to a player getting hit
 *
 * @return int errno
 */
int hitPlayerReaction();

/**
 * @brief Reacts to a caterpillar getting hit
 *
 * @param hitCaterpillarNode Node containing caterpillar that was hit
 * @param hitBulletNode Node containing bullet that hit caterpillar
 * @return int errno
 */
int hitCaterpillarReaction(ListNode* hitCaterpillarNode, ListNode* hitBulletNode);
#pragma once
/**
 * @file registry.h
 * @author Justen Di Ruscio
 * @brief A registry of game components for bullets to reference so the game components don't have to be passed around to the many bullets
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>

#include <jd/list.h>
#include <jd/threadpool.h>
#include <jd/task.h>

#include <caterpillar/user/player.h>

// Basic registry of game instances such that they don't need to be passed to
// shootBullet
typedef struct GameRegistryForBullet {
  Player *player;
  pthread_mutex_t *runningCatLock;
  List *runningCaterpillars;
  pthread_mutex_t *killedCatLock;
  List *killedCaterpillars;
  ThreadPool *tp;
  Task *sleepGame;
} GameRegistry;

extern GameRegistry registry;

void registerPlayerForBullets(Player* p);
void registerCaterpillarsForBullets(List* runningCaterpillars);
void registerThreadPoolForBullets(ThreadPool* const tp);
void registerSleepTaskForBullets(Task *const sleepGame);
void registerRunningCatLockForBullets(pthread_mutex_t *const runningCatLock);
void registerKilledCatLockForBullets(pthread_mutex_t *const killedCatLock);
void registerKilledCaterpillarsForBullets(List *const killedCaterpillars);
#pragma once
/**
 * @file caterpillar.h
 * @author Justen Di Ruscio
 * @brief Contains declarations of the Caterpillars and all related attributes
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/task.h>
#include <jd/list.h>

#include <caterpillar/game/game_console.h>
#include <caterpillar/game/constants.h>

#define CATERPILLAR_HEIGHT 2
#define SEGMENT_WIDTH 1
#define CATERPILLAR_ANIM_TILES 4

// move direction
typedef enum CaterpillarDirection {
  dir_Left = LEFT,
  dir_Right = RIGHT
} CaterpillarDirection;

typedef struct CaterpillarSegment {
  CaterpillarDirection direction;
  int animTile;
  int row;
  int col;
} CaterpillarSegment;

typedef struct Caterpillar {
  pthread_mutex_t locationMutex;
  int speedTicks;
  int numSegments;
  pthread_mutex_t bulletMutex;
  List shotBullets;
  CaterpillarSegment segments[GAME_COLS];
} Caterpillar;

typedef struct RunCaterpillarArg {
  Task *sleepGame;
  Caterpillar *caterpillar;
  Task* runCaterpillarTask;
  pthread_mutex_t *killedCatLock;
  List* killedCaterpillars;
} RunCaterpillarArg;

/**
 * @brief Clears a segment of the console at the provided location large enough to clear one caterpillar segment
 *
 * @param row
 * @param col
 */
void clearConsoleSegment(const int row, const int col);

/**
 * @brief Initializes the provided caterpillar
 *
 * @param c caterpillar
 * @param dir start direction
 * @param headRow head start row
 * @param headCol head start column
 * @param numSegments num segments in caterpillar
 * @param speedTicks ticks specifying init. speed
 * @return int errno
 */
int initCaterpillar(Caterpillar*const c, const CaterpillarDirection dir,
const int headRow, const int headCol, const int numSegments, const int
speedTicks);

/**
 * @brief Destroys the provided caterpillar
 *
 * @param c caterpillar
 * @return int errno
 */
int destroyCaterpillar(Caterpillar *const c);

/**
 * @brief Destroys the provided task and enclosed caterpillar
 *
 * @param task run caterpillar task
 */
void destroyCaterpillarTask(void* task);

/**
 * @brief Thread start function to run a caterpillar
 *
 * @param data RunCaterpillarArg
 * @return void* errno
 */
void* runCaterpillar(void* data);
#pragma once
/**
 * @file spawn_caterpillars.h
 * @author your name (you@domain.com)
 * @brief Contents relating to spawning caterpillars
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>

#include <jd/list.h>
#include <jd/task.h>
#include <jd/threadpool.h>

#include <caterpillar/caterpillars/caterpillar.h>

// provide to spawnCaterpillars
typedef struct SpawnCaterpillarsArg {
  pthread_mutex_t *const runningCatLock;
  List *const runningCaterpillars;
  Task *const sleepGame;
  ThreadPool *const threadPool;
  pthread_mutex_t *const killedCatLock;
  List* const killedCaterpillars;
} SpawnCaterpillarsArg;

/**
 * @brief Thread start function to spawn caterpillars at random intervals
 *
 * @param data SpawnCaterpillarArg
 * @return void* errno
 */
void* spawnCaterpillars(void* data);

/**
 * @brief Spawns a single caterpillar with segments copied from those provided.
 *
 * @param segs Segments to copy to new caterpillar
 * @param numSegs number of segments
 * @return Task* task containing spawned caterpillar
 */
Task* spawnCaterpillar(const CaterpillarSegment *segs, const int numSegs);
#pragma once

/**
 * @file constants.h
 * @author Justen Di Ruscio
 * @brief Global game constants
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

// =============== GAME BOARD ===================
#define GAME_ROWS 24 // number of rows in game board
#define GAME_COLS 80 // number of columns in game board
#define BOUNDARY_ROW 16 // row with player boundary
extern char *GAME_BOARD[]; // dimensions must match macros above

// =============== SCORE BOARD ===================
#define SCORE_COLS 26 // number of columns from left to print score
#define SCORE_ROWS 0 // number of rows from top to print score
#define SCORE_MAX_LENGTH 9 // max number of digits available to print score in
#define LIFE_COLS  42 // number of columns from left to print lives
#define LIFE_ROWS 0 // number of rows from top to print lives
#define LIFE_MAX_LENGTH 10 // max number of digits available to print score in

// =============== PLAYER START GAME ===================
#define PLAYER_START_COL 37 // number of columns from left to start player
#define PLAYER_START_ROW 20 // number of rows from top to start player
#define PLAYER_START_LIVES 10 // number of lives player starts with

// =============== PLAYER RATE LIMITS ===================
#define MOVE_MIN_SECS 0.01       // limit 1 movement per 0.01 seconds
#define BULLET_MIN_SECS 0.25       // limit 1 bullet per 0.25 seconds

// =============== CATERPILLAR ===================
#define CATERPILLAR_INIT_SPEED 30 // delay for speed in ticks
#define CATERPILLAR_HIT_SPEED_MULTIPLIER 1.5 // speed multiple when hit
#define CATERPILLAR_TOP_ROW  2 // top row of caterpillar area
#define CATERPILLAR_MIN_LENGTH 5 // min length before it's killed
#define CATERPILLAR_MIN_SPEED 8 // min ticks to determine max speed

// =============== BULLET ===================
#define BULLET_SHOOT_RATE_TICKS 10 // ticks to sleep before moving bullet

// =============== SCORING ===================
#define HIT_CATERPILLAR_SCORE 1
#define HIT_PLAYER_LIVES -1
#pragma once
/**
 * @file game.h
 * @author Justen Di Ruscio
 * @brief Main entry point for caterpillar game
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

void caterpillarRun();
#pragma once
/**
 * @file game_console.h
 * @author Justen Di Ruscio
 * @brief Declarations for game console. Used as wrapper around distribute/console
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>
#include <stdbool.h>

#include <jd/task.h>
#include "../distribute/console.h"

extern pthread_mutex_t consoleMutex;

// provide to runScreenRefresher
typedef struct RefreshArg {
  Task* const sleepGame;
} RefreshArg;

/**
 * @brief initializes game console
 *
 * @return true success
 * @return false failure
 */
bool gameConsoleInit();

/**
 * @brief Call at end of game to clean game console and destroy consoleMutex
 *
 * @return int errno
 */
int gameConsoleFinish();

/**
 * @brief thread start function to refresh console
 *
 * @param data RefreshArg
 * @return void* errno
 */
void* runScreenRefresher(void* data);
/**
 * @file upkeep.h
 * @author Justen Di Ruscio
 * @brief Upkeep game declarations
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#pragma once

#include <pthread.h>

#include <jd/task.h>
#include <jd/list.h>

#include <caterpillar/user/player.h>

// provide to runUpkeep
typedef struct UpkeepArg {
  Player* const p;
  Task* const sleepGame;
  pthread_mutex_t *const killedCatLock;
  List* const killedCaterpillars;
  char** const banner;
} UpkeepArg;

/**
 * @brief thread start function to upkeep game
 *
 * @param data UpkeepArg
 * @return void* errno
 */
void* runUpkeep(void* data);
#pragma once
/**
 * @file player.h
 * @author Justen Di Ruscio
 * @brief Declarations related to caterpillar game player, including space ship
 * on screen
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <stdbool.h>
#include <stdlib.h>
#include <pthread.h>

#include <jd/task.h>
#include <jd/list.h>

#define PLAYER_WIDTH 3
#define PLAYER_HEIGHT 3

typedef enum PlayerState
{
	GAME,
	DEAD,
	GAMEOVER
} PlayerState;


typedef struct Player
{
	// initial location for restarts
	int startCol;
	int startRow;

  // bullets fired by this player
	pthread_mutex_t bulletMutex;
	List shotBullets;

	// player state
	pthread_mutex_t stateMutex; // lives, score
	PlayerState state;
	int lives;
	int score;
	int animTile;

	// location of player
  pthread_mutex_t locationMutex;
	int row;
	int col;
} Player;

typedef struct RunPlayerArg {
	Task* const sleepGame;
	Player* const p;
} RunPlayerArg;

/**
 * @brief Initializes provided player
 *
 * @param p player
 * @param startRow
 * @param startCol
 * @param lives
 * @return int errno
 */
int initPlayer(Player *const p, const int startRow, const int startCol,
               const int lives);

/**
 * @brief destroys provided player
 *
 * @param p player
 * @return int errno
 */
int destroyPlayer(Player *const p);

/**
 * @brief Thread start function to run player
 *
 * @return void* errno
 */
void* runPlayer(void*);

/**
 * @brief Moves player to provided location and updates console
 *
 * @param p player
 * @param row new row
 * @param col new column
 * @param lock flag to lock player location or not`
 * @return int errno
 */
int movePlayer(Player *const p, int row, int col, const bool lock);
#pragma once
/**
 * @file player_state.h
 * @author Justen Di Ruscio
 * @brief Functions related to updating player state
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <caterpillar/user/player.h>

/**
 * @brief Updates the provided player's lives by the offset
 *
 * @param p player
 * @param offset
 * @param lives lives after update
 * @return int errno
 */
int updatePlayerLives(Player *const p, const int offset, int* const lives);

/**
 * @brief Updates the provided player's score by offset
 *
 * @param p player
 * @param offset
 * @return int errno
 */
int updatePlayerScore(Player *const p, const int offset);
#pragma once
/**
 * @file user_input.h
 * @author Justen Di Ruscio
 * @brief Declarations related to accepting user input to control player
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/task.h>

#include <caterpillar/user/player.h>

// provide to accept user input
typedef struct UserInputArg {
  Task* const sleepGame;
  Player* const p;
} UserInputArg;

/**
 * @brief Thread start function to accept user input
 *
 * @param data UserInputArg
 * @return void* errno
 */
void *acceptUserInput(void *data);
/**
 * @file bullet.c
 * @author Justen Di Ruscio
 * @brief Implementations for bullets and bullet shooting
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/bullets/bullet.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include "bullet_list.h"
#include <caterpillar/bullets/bullet_collisions.h>
#include <caterpillar/bullets/collision_reactions.h>
#include <caterpillar/bullets/registry.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>
#include <caterpillar/user/player_state.h>

// contains all the data necessary to shoot a bullet
// Task must be first
typedef struct ShootBulletData {
  Task runShootTask;
  Bullet b;
  RunShootBulletArg runShootArg;
  void *runShootResult;
} ShootBulletData;

// Characters displayed
#define BULLET_ANIM_TILES 2
char *bulletGraphic[BULLET_ANIM_TILES][BULLET_HEIGHT] = {{"^"}, {"*"}};

// ======================= Support Functions ========================
/**
 * @brief clears the provided location on the console to erase a bullet
 *
 * @param row
 * @param col
 * @return int errno
 */
static int clearConsoleBullet(const int row, const int col) {
  const char fooName[] = "clearConsoleBullet";

  errno = pthread_mutex_lock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to obtain lock before drawing bullet to screen "
            "in %s\n",
            fooName);
    return errno;
  }

  consoleClearImage(row, col, BULLET_HEIGHT, BULLET_WIDTH);

  errno = pthread_mutex_unlock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to release lock after drawing player to screen "
            "in %s\n",
            fooName);
  }
  return errno;
}

/**
 * @brief clears the current location of the provided bullet and redraws is at
 * the provided location. Sets errno on error
 *
 * @param b bullet
 * @param row
 * @param col
 * @return int errno
 */
static int redrawBullet(const Bullet *const b, const int row, const int col) {
  const char fooName[] = "redrawBullet";

  // Argument Validity Check
  errno = 0;
  if (b == (Bullet *)NULL) {
    fprintf(stderr, "argument 'b' of %s must point to a valid Bullet\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Draw moved player on game board
  errno = pthread_mutex_lock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to obtain lock before drawing bullet to screen "
            "in %s\n",
            fooName);
    return errno;
  }

  char **bulletImg = bulletGraphic[(int)b->bulletType];
  consoleClearImage(b->row, b->col, BULLET_HEIGHT, BULLET_WIDTH);
  consoleDrawImage(row, col, bulletImg, BULLET_HEIGHT);

  errno = pthread_mutex_unlock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to release lock after drawing player to screen "
            "in %s\n",
            fooName);
  }
  return errno;
}

/**
 * @brief Moves the provided bullet to the next segment
 *
 * @param bullet
 * @return int errno
 */
int moveBullet(Bullet *const bullet) {
  const char fooName[] = "moveBullet";

  // Argument Validity Check
  errno = 0;
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid bullet\n",
            fooName);
  }

  // Move Bullet
  errno = pthread_mutex_lock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure locking bullet location mutex in %s\n", fooName);
    return errno;
  }

  const int newRow = bullet->row + bullet->bulletType * 2 * DOWN + UP;
  redrawBullet(bullet, newRow, bullet->col);
  bullet->row = newRow;

  errno = pthread_mutex_unlock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure unlocking bullet location mutex in %s\n", fooName);
  }
  return errno;
}

// ================= Shoot Bullet Thread Start Function ==================
static void *runShootBullet(void *data) {
  const char fooName[] = "runShootBullet";
  const RunShootBulletArg *const arg = (RunShootBulletArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr, "argument 'data' of %s must point to a valid UpkeepArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->bullet == (Bullet *)NULL) {
    fprintf(stderr,
            "member 'bullet' of argument 'data' of %s must point to a bullet\n",
            fooName);
    errno = EPERM;
  } else if (arg->shootNode == (ListNode *)NULL) {
    fprintf(stderr,
            "member 'shootNode' of argument 'data' of %s must point to a "
            "ListNode\n",
            fooName);
    errno = EPERM;
  } else if (arg->shooter == (void *)NULL) {
    fprintf(stderr,
            "member 'shooter' of argument 'data' of %s must point to a "
            "Player or Caterpillar\n",
            fooName);
    errno = EPERM;
  }

  // Run Shoot Bullet
  else {
    Task *bulletTask = (*(Task **)arg->shootNode->data);
    while (!registry.sleepGame->completed && !bulletTask->completed) {
      // Delete bullet if it's off the play area
      const bool playerBulletEnd = arg->bullet->bulletType == b_Player &&
                                   arg->bullet->row == CATERPILLAR_TOP_ROW;
      const bool catBulletEnd = arg->bullet->bulletType == b_Caterpillar &&
                                arg->bullet->row == SCR_TOP + GAME_ROWS;
      if (playerBulletEnd || catBulletEnd) {
        errno = deleteBullet(arg->shooter, arg->shootNode, arg->bullet);
        if (errno != 0) {
          fprintf(stderr,
                  "Failure deleting bullet in %s after it ran off play area\n",
                  fooName);
        }
        break;
      }

      // Move Bullet
      errno = moveBullet(arg->bullet);
      if (errno != 0) {
        fprintf(stderr, "Failure moving bullet in %s %i\n", fooName, errno);
        break;
      }

      // Take action when bullet hits player/caterpillar
      if (arg->bullet->bulletType == b_Caterpillar) {
        const bool hit = hitPlayerLocked(arg->bullet, registry.player);
        if (hit) {
          errno = hitPlayerReaction();
          if (errno != 0) {
            fprintf(stderr, "Error while reacting to player hit in %s\n",
                    fooName);
          }
          break;
        }
      } else {
        ListNode *hitCaterpillarNode = NULL;
        const bool hit = hitCaterpillars(
            arg->bullet, registry.runningCaterpillars, &hitCaterpillarNode);
        if (hit) {
          errno = hitCaterpillarReaction(hitCaterpillarNode, arg->shootNode);
          if (errno != 0) {
            fprintf(stderr,
                    "Error while reacting to player caterpillar hit in %s\n",
                    fooName);
          }
          errno = updatePlayerScore(registry.player, +1);
          break;
        }
      }

      sleepTicks(BULLET_SHOOT_RATE_TICKS);
    }
  }

  clearConsoleBullet(arg->bullet->row, arg->bullet->col);

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(registry.sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }
  return (void *)(size_t)errno;
}

// ================= Public Bullet Functions ==================
int initBullet(Bullet *const b, const int row, const int col,
               const BulletType bType) {
  const char fooName[] = "initBullet";

  // Argument Validity Check
  errno = 0;
  if (b == (Bullet *)NULL) {
    fprintf(stderr, "argument 'b' of %s must point to a valid bullet\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Initialize Bullet
  errno = pthread_mutex_init(&b->locationMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Failure initializing bullet's location mutex in %s\n",
            fooName);
  }

  pthread_mutex_lock(&b->locationMutex);
  b->row = row;
  b->col = col;
  pthread_mutex_unlock(&b->locationMutex);
  b->bulletType = bType;
  return errno;
}

int destroyBullet(Bullet *const b) {
  const char fooName[] = "destroyBullet";
  errno = 0;
  // Return if there's nothing to destroy
  if (b == (Bullet *)NULL) {
    return errno;
  }

  errno = pthread_mutex_destroy(&b->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure destroying bullet's location mutex in %s\n",
            fooName);
  }
  return errno;
}

int shootBullet(const int row, const int col, const BulletType bType,
                void *const shooter) {
  const char fooName[] = "shootBullet";

  // Don't shoot bullets until all game instances are registered
  if (registry.player == NULL || registry.runningCaterpillars == NULL ||
      registry.tp == NULL || registry.sleepGame == NULL ||
      registry.runningCatLock == NULL) {
    return 0;
  }

  // Allocate memory to shoot new bullet
  void *bulletBytes = malloc(sizeof(ShootBulletData));
  if (bulletBytes == (void *)NULL) {
    fprintf(stderr, "Failure allocating memory to shoot bullet in %s\n",
            fooName);
    free(bulletBytes);
    return errno;
  }
  ShootBulletData *shootData = (ShootBulletData *)bulletBytes;

  // Locate bullet variables in allocated memory
  Task *const shootTask = &shootData->runShootTask;
  Bullet *const bullet = &shootData->b;
  RunShootBulletArg *const runShootArg = &shootData->runShootArg;
  void **const runResult = &shootData->runShootResult;

  ListNode *const shootNode = list_newNode(sizeof(Task *), &shootTask);
  if (shootNode == (ListNode *)NULL) {
    fprintf(stderr,
            "Unable to allocate memory for new node to contain bullets' task "
            "in %s\n",
            fooName);
    free(bulletBytes);
    return errno;
  }

  // Initialize bullet variables
  errno = initBullet(bullet, row, col, bType);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to initialize a new bullet to shoot in %s\n",
            fooName);
    free(bulletBytes);
    free(shootNode);
    return errno;
  }
  runShootArg->shootNode = shootNode;
  runShootArg->bullet = bullet;
  runShootArg->shooter = shooter;
  errno = task_init(shootTask, runShootBullet, runShootArg, runResult);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to initialize task to run spawned caterpillar "
            "in %s\n",
            fooName);
    free(bulletBytes);
    free(shootNode);
    return errno;
  }

  // Add shoot bullet task to shooter's list of bullets
  errno = addBulletToShooterList(shooter, shootNode, bType);
  if (errno != 0) {
    fprintf(stderr,
            "Failed to store shoot bullet task in shooter's list in %s\n",
            fooName);
    free(bulletBytes);
    free(shootNode);
  }

  // Shoot bullet on separate thread
  errno = tp_enqueueImmediate(registry.tp, shootTask);
  if (errno != 0) {
    fprintf(stderr, "Failed to run shot bullet on thread pool in %s\n",
            fooName);
    free(bulletBytes);
    free(shootNode);
    return errno;
  }
  return errno;
}

void deleteBulletTask(void *bulletTask) {
  const char fooName[] = "deleteBulletTask";
  if (bulletTask == NULL) {
    return;
  }

  Task *bt = (Task *)bulletTask;
  Bullet *bullet = ((RunShootBulletArg *)bt->fooArg)->bullet;

  // destroy the actual bullet
  errno = destroyBullet(bullet);
  if (errno != 0) {
    fprintf(stderr, "Failure to destroy a bullet in %s\n", fooName);
  }

  // destroy the bullet's task
  task_destroy(bulletTask);

  // free the bullet's task
  free(bulletTask);
}

int deleteBullet(void *const shooter, ListNode *const shootNode,
                 Bullet *const bullet) {
  const char fooName[] = "deleteBullet";

  // Argument Validity Checks
  if (shooter == (void *)NULL) {
    fprintf(stderr, "argument 'shooter' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }
  if (shootNode == (ListNode *)NULL) {
    fprintf(stderr,
            "argument 'shootNode' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // clear bullet from screen
  errno = clearConsoleBullet(bullet->row, bullet->col);
  if (errno != 0) {
    fprintf(stderr, "Failure clearing shooter's bullet in %s\n", fooName);
    return errno;
  }

  // Remove Bullet from shooter
  errno =
      eraseBulletFromShooterList(shooter, shootNode, bullet->bulletType, true);
  if (errno != 0) {
    fprintf(stderr,
            "Failure removing bullet from shooter's bullet list in %s\n",
            fooName);
    return errno;
  }

  return errno;
}
#include <caterpillar/bullets/bullet_collisions.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include <jd/list.h>

#include <caterpillar/bullets/registry.h>

// Collision detection specialized to single char bullet
#if BULLET_HEIGHT == 1 && BULLET_WIDTH == 1

// ============================ Support Functions =============================
/**
 * @brief Detects overlap between provided bullet and caterpillar. Sets errno on
 * error. Doesn't lock anything
 *
 * @param bullet
 * @param cat
 * @return true bullet hit cat
 * @return false no hit
 */
bool hitCaterpillarFoo(const Bullet *const bullet,
                       const Caterpillar *const cat) {
  const char fooName[] = "hitCaterpillar";

  // Argument Validity Checks
  errno = 0;
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (cat == (Caterpillar *)NULL) {
    fprintf(stderr, "argument 'cat' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Check if any of the caterpillar's segments overlap
  for (int segIdx = 0; segIdx < cat->numSegments; ++segIdx) {
    const CaterpillarSegment *const seg = cat->segments + segIdx;
    if (hitCaterpillarSegment(bullet, seg)) {
      return true;
    }
  }
  return false;
}

// ============================ Public Functions =============================
bool hitCaterpillarSegment(const Bullet *const b,
                           const CaterpillarSegment *const seg) {
  const char fooName[] = "hitCaterpillarSegment";

  // Argument Validity Check
  errno = 0;
  if (b == (Bullet *)NULL) {
    fprintf(stderr, "Argument 'b' of %s must point to a Bullet\b", fooName);
    errno = EPERM;
    return errno;
  }
  if (seg == (CaterpillarSegment *)NULL) {
    fprintf(stderr, "Argument 'c' of %s must point to a Caterpillar\b",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Check if they hit
  const int yDiff = b->row - seg->row;
  const bool verticalOverlap = yDiff >= 0 && yDiff < CATERPILLAR_HEIGHT;
  const bool horizontalOverlap = b->col == seg->col;
  return horizontalOverlap && verticalOverlap;
}

bool hitCaterpillars(Bullet *const bullet, List *const runningCaterpillars,
                     ListNode **hitCaterpillarNode) {
  const char fooName[] = "hitCaterpillars";

  // Argument Validity Checks
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (runningCaterpillars == (List *)NULL) {
    fprintf(
        stderr,
        "argument 'runningCaterpillars' of %s must point to a valid address\n",
        fooName);
    errno = EPERM;
    return false;
  }

  // Check if any caterpillars are hit
  // lock location mutexes so neither can move
  errno = pthread_mutex_lock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock running caterpillars mutex in %s\n",
            fooName);
    return false;
  }
  errno = pthread_mutex_lock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock bullet's location mutex in %s\n", fooName);
    return false;
  }

  bool hit = false;
  ListNode *n = runningCaterpillars->head;
  while (n != (ListNode *)NULL) {
    Task *caterpillarTask = *(Task **)n->data;
    RunCaterpillarArg *catArg = ((RunCaterpillarArg *)caterpillarTask->fooArg);
    Caterpillar *caterpillar = catArg->caterpillar;

    errno = pthread_mutex_lock(&caterpillar->locationMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure locking location mutex of caterpillar in %s\n",
              fooName);
    }

    hit = hitCaterpillarFoo(bullet, catArg->caterpillar);

    if (hit) {
      *hitCaterpillarNode = n;
      break;
    } else {
      errno = pthread_mutex_unlock(&caterpillar->locationMutex);
      if (errno != 0) {
        fprintf(stderr,
                "Failure unlocking location mutex of caterpillar in %s\n",
                fooName);
      }
    }

    n = n->next;
  }

  errno = pthread_mutex_unlock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Failure to unlock running caterpillars mutex in %s\n",
            fooName);
    return false;
  }

  if (!hit) {
    errno = pthread_mutex_unlock(&bullet->locationMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure to unlock bullet's location mutex in %s\n",
              fooName);
      return false;
    }
  }

  return hit;
}

bool anyBulletHitCaterpillar(Caterpillar *const caterpillar,
                             ListNode **hitBulletNode) {
  const char fooName[] = "anyBulletHitCaterpillar";
  bool hit = false;

  // Skip until player is registered
  if (registry.player == (Player *)NULL) {
    return false;
  }

  // Argument Validity Check
  errno = 0;
  if (caterpillar == (Caterpillar *)NULL) {
    fprintf(stderr,
            "argument 'caterpillar' of %s must point to a valid Caterpillar\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Check if any of the Player's shot bullet have hit caterpillar
  // lock player's bullets before iterating over them
  errno = pthread_mutex_lock(&registry.player->bulletMutex);
  if (errno != 0) {
    fprintf(stderr, "Unable to lock player's bullet mutex in %s\n", fooName);
    return false;
  }

  // for each of player's bullets, check if it hit caterpillar
  ListNode *bulletNode = registry.player->shotBullets.head;
  while (bulletNode != (ListNode *)NULL) {
    const Task *bulletTask = (*(Task **)bulletNode->data);
    Bullet *const b = ((RunShootBulletArg *)bulletTask->fooArg)->bullet;

    errno = pthread_mutex_lock(&b->locationMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure locking a bullet's location mutex in %s\n",
              fooName);
      return false;
    }

    const bool hit = hitCaterpillarFoo(b, caterpillar);

    errno = pthread_mutex_unlock(&b->locationMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure unlocking a bullet's location mutex in %s\n",
              fooName);
      return false;
    }

    if (hit) {
      *hitBulletNode = bulletNode;
      break;
    }

    bulletNode = bulletNode->next;
  }

  errno = pthread_mutex_unlock(&registry.player->bulletMutex);
  if (errno != 0) {
    fprintf(stderr, "Unable to unlock player's bullet mutex in %s\n", fooName);
    return false;
  }
  return hit;
}

bool hitPlayer(Bullet *const bullet, Player *const player) {
  const char fooName[] = "hitPlayer";

  // Argument Validity Checks
  errno = 0;
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (player == (Player *)NULL) {
    fprintf(stderr, "argument 'player' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Check if bullet overlaps with player
  // lock location mutexes so neither can move
  errno = pthread_mutex_lock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock bullet's location mutex in %s\n", fooName);
    return false;
  }

  const int yDiff = bullet->row - player->row;
  const int xDiff = bullet->col - player->col;

  errno = pthread_mutex_unlock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock bullet's location mutex in %s\n", fooName);
    return false;
  }

  return xDiff >= 0 && yDiff >= 0 && yDiff < PLAYER_HEIGHT &&
         xDiff < PLAYER_WIDTH;
}

bool hitPlayerLocked(Bullet *const bullet, Player *const player) {
  const char fooName[] = "hitPlayerLocked";

  // Argument Validity Checks
  errno = 0;
  if (bullet == (Bullet *)NULL) {
    fprintf(stderr, "argument 'bullet' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (player == (Player *)NULL) {
    fprintf(stderr, "argument 'player' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Check if bullet overlaps with player
  // lock location mutexes so neither can move
  errno = pthread_mutex_lock(&player->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock player's location mutex in %s\n", fooName);
    return false;
  }
  errno = pthread_mutex_lock(&player->bulletMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock player's location mutex in %s\n", fooName);
    return false;
  }
  errno = pthread_mutex_lock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to lock bullet's location mutex in %s\n", fooName);
    return false;
  }

  const int yDiff = bullet->row - player->row;
  const int xDiff = bullet->col - player->col;
  const bool hit =
      xDiff >= 0 && yDiff >= 0 && yDiff < PLAYER_HEIGHT && xDiff < PLAYER_WIDTH;

  if (!hit) {
    errno = pthread_mutex_unlock(&player->locationMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure to unlock player's location mutex in %s\n",
              fooName);
      return false;
    }
    errno = pthread_mutex_unlock(&player->bulletMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure to unlock player's location mutex in %s\n",
              fooName);
      return false;
    }
  }
  errno = pthread_mutex_unlock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to unlock bullet's location mutex in %s\n",
            fooName);
    return false;
  }
  return hit;
}

bool anyBulletHitPlayer(Player *const player, Caterpillar **shooter,
                        ListNode **hitBulletNode) {
  const char fooName[] = "anyBulletHitPlayer";
  bool hit = false;

  // Skip if caterpillars haven't been registered
  if (registry.runningCaterpillars == (List *)NULL ||
      registry.runningCatLock == NULL) {
    return false;
  }

  // Argument Validity Check
  errno = 0;
  if (player == (Player *)NULL) {
    fprintf(stderr,
            "argument 'player' of %s must point to the current player\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Check each shot bullet for each caterpillar
  errno = pthread_mutex_lock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Unable to lock running caterpillars mutex in %s\n",
            fooName);
    return false;
  }

  // for each caterpillar on the board
  const ListNode *caterpillarNode = registry.runningCaterpillars->head;
  while (caterpillarNode != (ListNode *)NULL) {
    const Task *const catTask = (*(Task **)caterpillarNode->data);
    Caterpillar *const caterpillar =
        ((RunCaterpillarArg *)catTask->fooArg)->caterpillar;

    // lock current caterpillar's bullet list before iterating its bullets
    errno = pthread_mutex_lock(&caterpillar->bulletMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure locking a Caterpillar's bullet mutex in %s\n",
              fooName);
      return false;
    }

    // check collision on each bullet of current caterpillar
    ListNode *bulletNode = caterpillar->shotBullets.head;
    while (bulletNode != (ListNode *)NULL) {
      const Task *const bTask = (*(Task **)bulletNode->data);
      Bullet *const bullet = ((RunShootBulletArg *)bTask->fooArg)->bullet;
      if (hitPlayer(bullet, registry.player)) {
        hit = true;
        *hitBulletNode = bulletNode;
        *shooter = caterpillar;
        break;
      }
      bulletNode = bulletNode->next;
    }

    errno = pthread_mutex_unlock(&caterpillar->bulletMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure unlocking a Caterpillar's bullet mutex in %s\n",
              fooName);
      return false;
    }

    if (hit) {
      break;
    }

    caterpillarNode = caterpillarNode->next;
  }

  errno = pthread_mutex_unlock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Unable to unlock running caterpillars mutex in %s\n",
            fooName);
    return false;
  }

  return hit;
}

#endif
/**
 * @file bullet_list.c
 * @author Justen Di Ruscio
 * @brief Function definitions for bullet_list.h
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include "bullet_list.h"

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include <caterpillar/bullets/registry.h>
#include <caterpillar/caterpillars/caterpillar.h>
#include <caterpillar/user/player.h>

// ========================= Support Functions =====================
/**
 * @brief erases all of the bullets from all of the caterpillar's lists
 *
 * @return int errno
 */
static int eraseCaterpillarsBullets() {
  const char fooName[] = "eraseCaterpillarsBullets";

  // for each running caterpillar
  const ListNode *caterpillarNode = registry.runningCaterpillars->head;
  while (caterpillarNode != (ListNode *)NULL) {
    const Task *const catTask = (*(Task **)caterpillarNode->data);
    Caterpillar *const caterpillar =
        ((RunCaterpillarArg *)catTask->fooArg)->caterpillar;

    // lock current caterpillar's bullet list before iterating its bullets
    errno = pthread_mutex_lock(&caterpillar->bulletMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure locking a Caterpillar's bullet mutex in %s\n",
              fooName);
      return false;
    }

    // erase shot bullets
    list_freeNodes(&caterpillar->shotBullets);

    errno = pthread_mutex_unlock(&caterpillar->bulletMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure unlocking a Caterpillar's bullet mutex in %s\n",
              fooName);
      return false;
    }

    caterpillarNode = caterpillarNode->next;
  }

  return errno;
}

// ======================== Public Bullet List Functions ====================
int eraseBulletFromShooterList(void *const shooter, ListNode *const bulletNode,
                               const BulletType type, const bool lock) {
  const char fooName[] = "removeBulletFromShooterList";

  // Argument Validity Check
  errno = 0;
  if (shooter == (void *)NULL) {
    fprintf(stderr, "argument 'shooter' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }
  if (bulletNode == (void *)NULL) {
    fprintf(stderr,
            "argument 'bulletNode' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Resolve shooter's bullets
  List *shooterBullets;
  pthread_mutex_t *shooterBulletMutex;
  if (type == b_Player) {
    Player *const p = (Player *)shooter;
    shooterBullets = &p->shotBullets;
    shooterBulletMutex = &p->bulletMutex;
  } else {
    Caterpillar *const c = (Caterpillar *)shooter;
    shooterBullets = &c->shotBullets;
    shooterBulletMutex = &c->bulletMutex;
  }

  // Remove bullet from shooter's list
  if (lock) {
    errno = pthread_mutex_lock(shooterBulletMutex);
    if (errno != 0) {
      fprintf(stderr, "unable to lock shooter's bullet mutex in %s\n", fooName);
      return errno;
    }
  }

  bool erased = true;
  if (list_containsNode(shooterBullets, bulletNode)) {
    erased = list_eraseNode(shooterBullets, bulletNode);
    if (!erased) {
      fprintf(stderr, "Failure erasing bullet from shooter's list in %s\n",
              fooName);
    }
  }

  if (lock) {
    errno = pthread_mutex_unlock(shooterBulletMutex);
    if (errno != 0) {
      fprintf(stderr, "unable to unlock shooter's bullet mutex in %s\n",
              fooName);
    }
  }
  return errno;
}

int addBulletToShooterList(void *const shooter, ListNode *const bulletNode,
                           const BulletType type) {
  const char fooName[] = "addBulletToShooterList";

  // Argument Validity Check
  errno = 0;
  if (shooter == (void *)NULL) {
    fprintf(stderr, "argument 'shooter' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }
  if (bulletNode == (void *)NULL) {
    fprintf(stderr,
            "argument 'bulletNode' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Resolve shooter's bullets
  List *shooterBullets;
  pthread_mutex_t *shooterBulletMutex;
  if (type == b_Player) {
    Player *const p = (Player *)shooter;
    shooterBullets = &p->shotBullets;
    shooterBulletMutex = &p->bulletMutex;
  } else {
    Caterpillar *const c = (Caterpillar *)shooter;
    shooterBullets = &c->shotBullets;
    shooterBulletMutex = &c->bulletMutex;
  }

  // Add bullet to shooter's list
  errno = pthread_mutex_lock(shooterBulletMutex);
  if (errno != 0) {
    fprintf(stderr, "unable to lock shooter's bullet mutex in %s\n", fooName);
    return errno;
  }

  const bool pushed = list_pushNodeBack(shooterBullets, bulletNode);
  if (!pushed) {
    fprintf(stderr, "Failure pushing bullet to shooter's list in %s\n",
            fooName);
  }

  errno = pthread_mutex_unlock(shooterBulletMutex);
  if (errno != 0) {
    fprintf(stderr, "unable to unlock shooter's bullet mutex in %s\n", fooName);
  }
  return errno;
}

int eraseAllBullets() {
  const char fooName[] = "eraseAllBullets";
  errno = 0;
  // Error if caterpillars/player haven't been registered
  if (registry.runningCaterpillars == NULL || registry.runningCatLock == NULL ||
      registry.player == NULL) {
    fprintf(stderr, "Game components must be registered before using %s\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // lock running caterpillars before iterating over them
  errno = pthread_mutex_lock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Unable to lock running caterpillars mutex in %s\n",
            fooName);
    return false;
  }

  // erase player's bullets
  list_freeNodes(&registry.player->shotBullets);

  // erase caterpillar's bullets
  errno = eraseCaterpillarsBullets();
  if (errno != 0) {
    fprintf(stderr, "Failure erasing caterpillar bullets in %s\n", fooName);
    return errno;
  }

  errno = pthread_mutex_unlock(registry.runningCatLock);
  if (errno != 0) {
    fprintf(stderr, "Unable to unlock running caterpillars mutex in %s\n",
            fooName);
  }
  return errno;
}
/**
 * @file collision_reactions.c
 * @author Justen Di Ruscio
 * @brief Contains definitions for functions reacting to player/caterpillar
 * getting hit
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/bullets/collision_reactions.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include "bullet_list.h"
#include <caterpillar/bullets/bullet.h>
#include <caterpillar/bullets/bullet_collisions.h>
#include <caterpillar/bullets/registry.h>
#include <caterpillar/caterpillars/caterpillar.h>
#include <caterpillar/caterpillars/spawn_caterpillars.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/user/player_state.h>

#define PlAYER_HIT_PAUSE_TICKS 100

int hitPlayerReaction() {
  const char fooName[] = "hitPlayerReaction";
  errno = 0;

  // Reduce Player's lives
  int playerLives = PLAYER_START_LIVES;
  errno = updatePlayerLives(registry.player, HIT_PLAYER_LIVES, &playerLives);
  if (errno != 0) {
    fprintf(stderr, "Failure updating player's lives in %s\n", fooName);
    return errno;
  }

  // Erase all bullets on screen
  errno = eraseAllBullets();
  if (errno != 0) {
    fprintf(stderr, "Failure erasing all bullets on game board in %s\n",
            fooName);
  }

  // Respawn player
  movePlayer(registry.player, registry.player->startRow,
             registry.player->startCol, false);

  // Delay game or end game
  // end game if player's lives are 0
  if (playerLives == 0) { // lose
    task_markCompleted(registry.sleepGame);
  } else {
    sleepTicks(PlAYER_HIT_PAUSE_TICKS);
  }

  // Unlock all locked mutexes from hit
  errno = pthread_mutex_unlock(&registry.player->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to unlock player's location mutex in %s\n",
            fooName);
    return false;
  }
  errno = pthread_mutex_unlock(&registry.player->bulletMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to unlock player's location mutex in %s\n",
            fooName);
    return false;
  }
  return errno;
}

int hitCaterpillarReaction(ListNode *hitCaterpillarNode,
                           ListNode *hitBulletNode) {
  const char fooName[] = "hitCaterpillarReaction";
  errno = 0;

  // Set variables
  Task *const caterpillarTask = *((Task **)hitCaterpillarNode->data);
  Caterpillar *hitCaterpillar =
      ((RunCaterpillarArg *)caterpillarTask->fooArg)->caterpillar;
  Task *const bulletTask = *((Task **)hitBulletNode->data);
  Bullet *bullet = ((RunShootBulletArg *)bulletTask->fooArg)->bullet;

  // Update the player's score
  errno = updatePlayerScore(registry.player, HIT_CATERPILLAR_SCORE);
  if (errno != 0) {
    fprintf(stderr, "Failure updating player's score in %s\n", fooName);
    return errno;
  }

  // Resolve new lengths
  int newLength = 0;
  for (int segIdx = 0; segIdx < hitCaterpillar->numSegments; ++segIdx) {
    const CaterpillarSegment *const seg = hitCaterpillar->segments + segIdx;
    if (hitCaterpillarSegment(bullet, seg)) {
      newLength = segIdx;
      break;
    }
  }

  // Spawn new caterpillar
  Task *spawnTask = NULL;
  if (hitCaterpillar->numSegments - newLength >= CATERPILLAR_MIN_LENGTH) {
    spawnTask = spawnCaterpillar(hitCaterpillar->segments + newLength,
                                 hitCaterpillar->numSegments - newLength);
  }

  // Shrink Caterpillar to new length or stop if it's length is too small
  // shrink
  if (newLength >= CATERPILLAR_MIN_LENGTH) {
    // clear truncated segments
    for (int i = newLength; i < hitCaterpillar->numSegments; ++i) {
      CaterpillarSegment *const seg = hitCaterpillar->segments + i;
      clearConsoleSegment(seg->row, seg->col);
    }
    // reduce size
    hitCaterpillar->numSegments = newLength;

    // increase speed of hit caterpillar
    int newSpeed =
        hitCaterpillar->speedTicks / CATERPILLAR_HIT_SPEED_MULTIPLIER;
    if (newSpeed < CATERPILLAR_MIN_SPEED) {
      newSpeed = CATERPILLAR_MIN_SPEED;
    }
    hitCaterpillar->speedTicks = newSpeed;

  }

  // Stop
  else {
    // Stop running caterpillar
    // location already locked
    pthread_mutex_lock(&hitCaterpillar->bulletMutex);
    errno = task_markCompleted(caterpillarTask);
    if (errno != 0) {
      fprintf(stderr,
              "Failure marking caterpillar task completed to erase caterpillar "
              "in %s\n",
              fooName);
    }
    pthread_mutex_unlock(&hitCaterpillar->bulletMutex);
  }

  // Unlock all mutexes
  errno = pthread_mutex_unlock(&hitCaterpillar->locationMutex);
  if (errno != 0) {
    return errno;
  }

  // unlock bullet location to delete bullet
  errno = pthread_mutex_unlock(&bullet->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure to unlock bullet's location mutex in %s\n",
            fooName);
    return errno;
  }

  // Delete player bullet that hit caterpillar
  errno = deleteBullet(registry.player, hitBulletNode, bullet);
  if (errno != 0) {
    fprintf(stderr, "Failure deleting player's bullet in %s\n", fooName);
    return errno;
  }

  // run new caterpillar on game board
  if (spawnTask != NULL) {
    errno = tp_enqueueImmediate(registry.tp, spawnTask);
    if (errno != 0) {
      fprintf(stderr,
              "Failure in %s trying to run spawned caterpillar in threadpool\n",
              fooName);
    }
  }

  return errno;
}
/**
 * @file registry.c
 * @author Justen Di Ruscio
 * @brief A registry of game components for bullets to reference so the game
 * components don't have to be passed around to the many bullets
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/bullets/registry.h>

GameRegistry registry;

void registerCaterpillarsForBullets(List *runningCaterpillars) {
  registry.runningCaterpillars = runningCaterpillars;
}

void registerThreadPoolForBullets(ThreadPool *const tp) { registry.tp = tp; }

void registerSleepTaskForBullets(Task *const sleepGame) {
  registry.sleepGame = sleepGame;
}

void registerPlayerForBullets(Player *p) { registry.player = p; }

void registerRunningCatLockForBullets(pthread_mutex_t *const runningCatLock) {
  registry.runningCatLock = runningCatLock;
}

void registerKilledCatLockForBullets(pthread_mutex_t *const killedCatLock) {
  registry.killedCatLock = killedCatLock;
}

void registerKilledCaterpillarsForBullets(List *const killedCaterpillars) {
  registry.killedCaterpillars = killedCaterpillars;
}
/**
 * @file caterpillar.c
 * @author Justen Di Ruscio
 * @brief Contains definitions of the Caterpillar functions
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/caterpillars/caterpillar.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#include <caterpillar/bullets/bullet.h>
#include <caterpillar/bullets/bullet_collisions.h>
#include <caterpillar/bullets/collision_reactions.h>
#include <caterpillar/bullets/registry.h>

// ========================== Global Constants ============================
#define CATERPILLAR_ANIM_TICKS 50

char *segmentGraphic[CATERPILLAR_ANIM_TILES][CATERPILLAR_HEIGHT] = {
    {"=", ";"}, {"=", ":"}, {"=", ":"}, {"0", " "}};

// ======================= Support Functions ========================
static int moveCaterpillarAndDraw(Caterpillar *const c) {
  const char fooName[] = "moveCaterpillarAndDraw";

  // Argument Validity Check
  if (c == (Caterpillar *)NULL) {
    fprintf(stderr, "Argument 'c' of %s must point to a Caterpillar\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Move Caterpillar by one unit in direction
  errno = pthread_mutex_lock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to lock console mutex before drawing "
            "Caterpillar in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_lock(&c->locationMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to lock Caterpillar's location mutex before "
            "drawing Caterpillar in %s\n",
            fooName);
    return errno;
  }

  // move each segment of caterpillar to move caterpillar
  for (int segIdx = 0; segIdx < c->numSegments; ++segIdx) {
    CaterpillarSegment *seg = c->segments + segIdx;
    int newRow = seg->row;
    int newCol = seg->col + seg->direction;
    CaterpillarDirection newDir = seg->direction;

    // move segment down and flip direction if it hits horizontal border
    const bool hitLeft = (newCol < SCR_LEFT) && seg->direction == dir_Left;
    const bool hitRight = (newCol >= GAME_COLS) && seg->direction == dir_Right;
    if (hitLeft || hitRight) {
      newCol = seg->col;
      newRow += CATERPILLAR_HEIGHT * DOWN;
      newDir = -newDir; // flip direction
    }

    // move segments up if head's going into player/caterpillar boundary row
    if (segIdx == 0 && newRow == BOUNDARY_ROW) {
      newRow += CATERPILLAR_HEIGHT * UP;
      for (int i = 1; i < c->numSegments; ++i) {
        clearConsoleSegment(c->segments[i].row, c->segments[i].col);
        c->segments[i].row += CATERPILLAR_HEIGHT * UP;
      }
    }

    // clear current segment location before drawing new location
    else {
      clearConsoleSegment(seg->row, seg->col);
    }

    // move segment to new location
    char **segImg = segmentGraphic[seg->animTile];
    consoleDrawImage(newRow, newCol, segImg, CATERPILLAR_HEIGHT);
    seg->row = newRow;
    seg->col = newCol;
    seg->direction = newDir;
  }

  errno = pthread_mutex_unlock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to unlock console mutex after drawing "
            "Caterpillar in %s\n",
            fooName);
  }

  errno = pthread_mutex_unlock(&c->locationMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to unlock Caterpillar's location mutex before "
            "drawing Caterpillar in %s\n",
            fooName);
    return errno;
  }

  return errno;
}

// ======================= Public Caterpillar Functions ========================
void clearConsoleSegment(const int row, const int col) {
  consoleClearImage(row, col, CATERPILLAR_HEIGHT, SEGMENT_WIDTH);
}

int initCaterpillar(Caterpillar *const c, const CaterpillarDirection dir,
                    const int headRow, const int headCol, const int numSegments,
                    const int speedTicks) {
  const char fooName[] = "initCaterpillar";

  // Argument Validity Check
  errno = 0;
  if (c == (Caterpillar *)NULL) {
    fprintf(stderr, "Argument 'c' of %s must point to a Caterpillar\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Initialize Caterpillar and its segments
  errno = pthread_mutex_init(&c->locationMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Unable to initialize caterpillar's location mutex in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_init(&c->bulletMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Unable to initialize caterpillar's bullet mutex in %s\n",
            fooName);
    return errno;
  }

  c->numSegments = numSegments;
  c->speedTicks = speedTicks;

  pthread_mutex_lock(&c->bulletMutex);
  c->shotBullets = list_constructEmpty(sizeof(Task *));
  c->shotBullets.elementDeleter = deleteBulletTask;
  pthread_mutex_unlock(&c->bulletMutex);

  pthread_mutex_lock(&c->locationMutex);
  for (int segIdx = 0; segIdx < numSegments; ++segIdx) {
    CaterpillarSegment seg;
    seg.row = headRow;
    seg.col = headCol + segIdx * -dir; // backwards from head col
    seg.direction = dir;
    if (segIdx == 0) { // head segment
      seg.animTile = CATERPILLAR_ANIM_TILES - 1;
    } else { // body segment
      seg.animTile = segIdx % (CATERPILLAR_ANIM_TILES - 1);
    }
    c->segments[segIdx] = seg;
  }
  pthread_mutex_unlock(&c->locationMutex);
  return 0;
}

int destroyCaterpillar(Caterpillar *const c) {
  const char fooName[] = "destroyCaterpillar";
  errno = pthread_mutex_destroy(&c->locationMutex);
  if (errno != 0) {
    fprintf(stderr, "Unable to initialize caterpillar's location mutex in %s\n",
            fooName);
    return errno;
  }
  errno = pthread_mutex_destroy(&c->bulletMutex);
  if (errno != 0) {
    fprintf(stderr, "Unable to initialize caterpillar's bullet mutex in %s\n",
            fooName);
    return errno;
  }
  list_freeNodes(&c->shotBullets);
  return errno;
}

void destroyCaterpillarTask(void *task) {
  const char fooName[] = "destroyCaterpillarTask";

  // Return if there's nothing to destroy
  if (task == NULL) {
    return;
  }
  Task *const t = (Task *)task;
  if (t->fooArg == NULL) {
    return;
  }

  // Get Caterpillar from Task
  Caterpillar *const taskCaterpillar =
      ((RunCaterpillarArg *)t->fooArg)->caterpillar;

  // Destroy the Caterpillar itself
  errno = destroyCaterpillar(taskCaterpillar);
  if (errno != 0) {
    fprintf(stderr, "Failure destroying one of the Caterpillars in %s\n",
            fooName);
  }

  task_destroy(task);
  free(task);
}

// ==================== Caterpillar Thread Start Functions =====================
void *runCaterpillar(void *data) {
  const char fooName[] = "runCaterpillar";
  const RunCaterpillarArg *const arg = (RunCaterpillarArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr, "argument 'data' of %s must point to a valid UpkeepArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->caterpillar == (Caterpillar *)NULL) {
    fprintf(stderr,
            "member 'caterpillar' of argument 'data' of %s must point to a "
            "Caterpillar\n",
            fooName);
    errno = EPERM;
  } else if (arg->runCaterpillarTask == (Task *)NULL) {
    fprintf(stderr,
            "member 'runCaterpillarTask' of argument 'data' of %s must point "
            "to a Task\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCatLock == (pthread_mutex_t *)NULL) {
    fprintf(stderr,
            "member 'killedCatLock' of argument 'data' of %s must point to the "
            "lock for killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCaterpillars == (List *)NULL) {
    fprintf(stderr,
            "member 'killedCaterpillars' of argument 'data' of %s must point "
            "to the list of killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  }

  // Run Caterpillar
  else {
    int movesSinceShoot = 0;
    while (!arg->sleepGame->completed && !arg->runCaterpillarTask->completed) {
      const int movesBeforeShoot = 1 + rand() % (int)(GAME_COLS / 1.5);
      // Update segments' animation to animate caterpillar
      CaterpillarSegment *const segments = arg->caterpillar->segments;
      for (int catSeg = 1; catSeg < arg->caterpillar->numSegments; ++catSeg) {
        segments[catSeg].animTile =
            (segments[catSeg].animTile + 1) % (CATERPILLAR_ANIM_TILES - 1);
      }

      // Move Caterpillar
      moveCaterpillarAndDraw(arg->caterpillar);

      // At random intervals, shoot bullets
      if (++movesSinceShoot >= movesBeforeShoot) {
        const CaterpillarSegment *const head = arg->caterpillar->segments;
        shootBullet(head->row + DOWN, head->col, b_Caterpillar,
                    arg->caterpillar);
        movesSinceShoot = 0;
      }
      sleepTicks(arg->caterpillar->speedTicks);
    }
  }

  // Clear Caterpillar segments
  for (int segIdx = 0; segIdx < arg->caterpillar->numSegments; ++segIdx) {
    CaterpillarSegment *const seg = arg->caterpillar->segments + segIdx;
    clearConsoleSegment(seg->row, seg->col);
  }

  // Remove run caterpillar task from running list
  errno = pthread_mutex_lock(registry.runningCatLock);
  ListNode *node = registry.runningCaterpillars->head;
  while (node != NULL) {
    Task *t = *((Task **)(node->data));
    if (t == arg->runCaterpillarTask) {
      break;
    }
    node = node->next;
  }
  list_removeNode(registry.runningCaterpillars, node);
  errno = pthread_mutex_unlock(registry.runningCatLock);

  // Add run caterpillar task to killed list
  errno = pthread_mutex_lock(arg->killedCatLock);
  if (errno != 0) {
    fprintf(stderr, "Unable to lock list of killed caterpillars in %s\n",
            fooName);
  } else if (node != NULL) {
    const bool pushed = list_pushNodeBack(arg->killedCaterpillars, node);
    int err = 0;
    if (!pushed) {
      fprintf(
          stderr,
          "Failed adding caterpillar task to killed caterpillars list in  %s\n",
          fooName);
      err = errno;
    }

    errno = pthread_mutex_unlock(arg->killedCatLock);
    if (errno != 0) {
      fprintf(stderr, "Unable to unlock list of killed caterpillars in %s\n",
              fooName);
    }
    errno = err;
  }

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }

  return (void *)(size_t)errno;
}
/**
 * @file spawn_caterpillars.c
 * @author Justen Di Ruscio
 * @brief Definitions relating to spawning caterpillars
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/caterpillars/spawn_caterpillars.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#include <caterpillar/bullets/registry.h>
#include <caterpillar/caterpillars/caterpillar.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>

// ================= Private Structures =====================
// data necessary to spawn a new caterpillar
typedef struct CaterpillarData {
  Task runTask;
  Caterpillar cat;
  RunCaterpillarArg runArg;
  void *runResult;
} CaterpillarData;

// ================= Spawn Caterpillar Support Functions =====================
#define CATERPILLAR_SPAWN_COL GAME_COLS     // column to spawn caterpillars
const int spawnNumSegments = GAME_COLS - 5; // length of spawned caterpillars
const CaterpillarDirection startDir = dir_Left; // spawned caterpillar dir
const int spawnRateTicks =
    CATERPILLAR_INIT_SPEED * 15; // longest num ticks between spawns

// ================= Spawn Caterpillar Support Functions =====================
void sleepTicksUntil(const int ticks, const Task *const sleepGame) {
  for (int sleep = CATERPILLAR_INIT_SPEED; sleep <= ticks;
       sleep += CATERPILLAR_INIT_SPEED) {
    if (sleepGame->completed) {
      return;
    }
    sleepTicks(sleep);
  }
}

// ================= Spawn Caterpillar Thread Start Function ==================
void *spawnCaterpillars(void *data) {
  const char fooName[] = "spawnCaterpillars";
  SpawnCaterpillarsArg *const arg = (SpawnCaterpillarsArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(
        stderr,
        "argument 'data' of %s must point to a valid SpawnCaterpillarsArg\n",
        fooName);
    errno = EPERM;
  } else if (arg->runningCaterpillars == (List *)NULL) {
    fprintf(stderr,
            "member 'runningCaterpillars' of argument 'data' of %s must point "
            "to the list of caterpillars\n ",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  } else if (arg->threadPool == (ThreadPool *)NULL) {
    fprintf(stderr,
            "member 'threadPool' of argument 'data' of %s must point to the "
            "game's threadpool\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCatLock == (pthread_mutex_t *)NULL) {
    fprintf(stderr,
            "member 'killedCatLock' of argument 'data' of %s must point to the "
            "lock for killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCaterpillars == (List *)NULL) {
    fprintf(stderr,
            "member 'killedCaterpillars' of argument 'data' of %s must point "
            "to the list of killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->runningCatLock == (pthread_mutex_t *)NULL) {
    fprintf(
        stderr,
        "member 'runningCatLock' of argument 'data' of %s must point a mutex\n",
        fooName);
    errno = EPERM;
  }

  // Spawn Caterpillars
  else {
    while (!arg->sleepGame->completed) {
      // allocate memory to spawn new caterpillar
      const void *const catData_ = malloc(sizeof(CaterpillarData));
      if (errno != 0) {
        fprintf(stderr,
                "Failure trying to allocate memory to spawn a new caterpillar "
                "in %s\n",
                fooName);
        free((void *)catData_);
        break;
      }
      CaterpillarData *caterpillarData = (CaterpillarData *)catData_;

      // locate caterpillar variables in allocated mem
      Task *const runTask = &caterpillarData->runTask;
      Caterpillar *const caterpillar = &caterpillarData->cat;
      RunCaterpillarArg *const runArg = &caterpillarData->runArg;
      void **const runResult = &caterpillarData->runResult;

      // initialize caterpillar variables
      errno = initCaterpillar(caterpillar, startDir, CATERPILLAR_TOP_ROW,
                              CATERPILLAR_SPAWN_COL, spawnNumSegments,
                              CATERPILLAR_INIT_SPEED);
      if (errno != 0) {
        fprintf(
            stderr,
            "Failure trying to initialize a new caterpillar to spawn in %s\n",
            fooName);
        free((void *)catData_);
        break;
      }
      const int spawnDuration =
          caterpillar->speedTicks * caterpillar->numSegments;
      const int timeBetweenSpawn = rand() % spawnRateTicks;
      runArg->caterpillar = caterpillar;
      runArg->sleepGame = arg->sleepGame;
      runArg->runCaterpillarTask = runTask;
      runArg->killedCatLock = arg->killedCatLock;
      runArg->killedCaterpillars = arg->killedCaterpillars;
      errno = task_init(runTask, runCaterpillar, runArg, runResult);
      if (errno != 0) {
        fprintf(stderr,
                "Failure trying to initialize task to run spawned caterpillar "
                "in %s\n",
                fooName);
        free((void *)catData_);
        break;
      }

      // add new caterpillar task to list of running caterpillars on game board
      errno = pthread_mutex_lock(arg->runningCatLock);
      const bool pushed = list_pushBack(arg->runningCaterpillars, &runTask);
      if (!pushed) {
        fprintf(stderr,
                "Failure in %s trying to add running caterpillar to list of "
                "caterpillars on game board\n",
                fooName);
        free((void *)catData_);
        break; // errno set by list_pushBack
      }
      pthread_mutex_unlock(arg->runningCatLock);

      // run new caterpillar on game board
      errno = tp_enqueueImmediate(arg->threadPool, runTask);
      if (errno != 0) {
        fprintf(
            stderr,
            "Failure in %s trying to run spawned caterpillar in thread pool\n",
            fooName);
        free((void *)catData_);
        break;
      }

      // Sleep for random interval before spawning new caterpillar
      sleepTicksUntil(spawnDuration + timeBetweenSpawn, arg->sleepGame);
    }
  }

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }

  return (void *)(size_t)errno;
}

Task *spawnCaterpillar(const CaterpillarSegment *segs, const int numSegs) {
  const char fooName[] = "spawnCaterpillar";

  // allocate memory to spawn new caterpillar
  const void *const catData_ = malloc(sizeof(CaterpillarData));
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to allocate memory to spawn a new caterpillar "
            "in %s\n",
            fooName);
    free((void *)catData_);
    return NULL;
  }
  CaterpillarData *caterpillarData = (CaterpillarData *)catData_;

  // locate caterpillar variables in allocated mem
  Task *const runTask = &caterpillarData->runTask;
  Caterpillar *const caterpillar = &caterpillarData->cat;
  RunCaterpillarArg *const runArg = &caterpillarData->runArg;
  void **const runResult = &caterpillarData->runResult;

  // Initialize caterpillar variables
  errno =
      initCaterpillar(caterpillar, startDir, CATERPILLAR_TOP_ROW,
                      CATERPILLAR_SPAWN_COL, numSegs, CATERPILLAR_INIT_SPEED);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to initialize a new caterpillar to spawn in %s\n",
            fooName);
    free((void *)catData_);
    return NULL;
  }
  for (int i = 0; i < numSegs; ++i) { // copy segments
    CaterpillarSegment *destSeg = caterpillar->segments + i;
    const CaterpillarSegment *srcSeg = segs + i;
    *destSeg = *srcSeg;
  }
  caterpillar->segments[0].animTile = CATERPILLAR_ANIM_TILES - 1;
  runArg->caterpillar = caterpillar;
  runArg->sleepGame = registry.sleepGame;
  runArg->runCaterpillarTask = runTask;
  runArg->killedCatLock = registry.killedCatLock;
  runArg->killedCaterpillars = registry.killedCaterpillars;
  errno = task_init(runTask, runCaterpillar, runArg, runResult);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to initialize task to run spawned caterpillar "
            "in %s\n",
            fooName);
    free((void *)catData_);
    return NULL;
  }

  // add new caterpillar task to list of running caterpillars on game board
  errno = pthread_mutex_lock(registry.runningCatLock);
  const bool pushed = list_pushBack(registry.runningCaterpillars, &runTask);
  if (!pushed) {
    fprintf(stderr,
            "Failure in %s trying to add running caterpillar to list of "
            "caterpillars on game board\n",
            fooName);
    free((void *)catData_);
    return NULL; // errno set by list_pushBack
  }
  pthread_mutex_unlock(registry.runningCatLock);

  return runTask;
}
/**
 * @file constants.c
 * @author Justen Di Ruscio
 * @brief definition of the game board
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/game/constants.h>

#include <caterpillar/game/game_console.h>

char *GAME_BOARD[] = {
    "                   Score:          Lives:",
    "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-caterpillar!=-=-=-=-=-=-=-=-=-=-=-=-=-"
    "=-=-=-",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
    "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
    "\"\"\"\"\"\"",
    "",
    "",
    "",
    "",
    "",
    "",
    ""};
/**
 * @file game.c
 * @author Justen Di Ruscio
 * @brief Main entry point for caterpillar game
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/game/game.h>

#include <pthread.h>
#include <stdio.h>

#include <jd/error.h>
#include <jd/list.h>
#include <jd/task.h>
#include <jd/threadpool.h>

#include <caterpillar/bullets/bullet.h>
#include <caterpillar/bullets/registry.h>
#include <caterpillar/caterpillars/caterpillar.h>
#include <caterpillar/caterpillars/spawn_caterpillars.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>
#include <caterpillar/upkeep.h>
#include <caterpillar/user/player.h>
#include <caterpillar/user/user_input.h>

void *noop(void *data) { return data; }

// ======================= Public Game Function ========================
void caterpillarRun(ThreadPool *const threadPool) {
  const char fooName[] = "caterpillarRun";
  char *banner = "DONE - LOSE";

  if (gameConsoleInit()) {
    registerThreadPoolForBullets(threadPool);

    // ========== VARS TO SLEEP GAME WHILE RUNNING =============
    // Task used to sleep game until completion
    // being used with noop to effectively create a promise & future pair
    // instead of a packaged task & future pair
    Task sleepGame;
    errno = task_init(&sleepGame, noop, NULL, NULL);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize sleep game task in %s\n", fooName);
      task_destroy(&sleepGame);
      handleExitError(errno);
    }
    registerSleepTaskForBullets(&sleepGame);
    errno = task_execute(&sleepGame);
    if (errno != 0) {
      fprintf(stderr, "Unable to execute sleep game task in %s\n", fooName);
      task_destroy(&sleepGame);
      handleExitError(errno);
    }

    // ========== PLAYER THREAD =============
    Player p;
    errno =
        initPlayer(&p, PLAYER_START_ROW, PLAYER_START_COL, PLAYER_START_LIVES);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize player in %s\n", fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      handleExitError(errno);
    }
    registerPlayerForBullets(&p);
    Task playerTask;
    void *runPlayerResult;
    RunPlayerArg playerArg = {.p = &p, .sleepGame = &sleepGame};
    errno = task_init(&playerTask, runPlayer, &playerArg, &runPlayerResult);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize player in %s\n", fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      handleExitError(errno);
    }
    errno = tp_enqueueImmediate(threadPool, &playerTask);
    if (errno != 0) {
      fprintf(stderr, "Unable to add player task to thread pool in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      handleExitError(errno);
    }

    // ========== SCREEN REFRESHER THREAD =============
    Task screenRefresherTask;
    void *screenRefreshResult;
    RefreshArg refreshArg = {.sleepGame = &sleepGame};
    errno = task_init(&screenRefresherTask, runScreenRefresher, &refreshArg,
                      &screenRefreshResult);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize screen refresher task in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      handleExitError(errno);
    }
    errno = tp_enqueueImmediate(threadPool, &screenRefresherTask);
    if (errno != 0) {
      fprintf(stderr, "Unable to add refresher task to threadpool in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      handleExitError(errno);
    }

    // ========== USER INPUT THREAD =============
    Task userInputTask;
    void *userInputResult;
    UserInputArg inputArg = {.p = &p, .sleepGame = &sleepGame};
    errno =
        task_init(&userInputTask, acceptUserInput, &inputArg, &userInputResult);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize user input thread in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      handleExitError(errno);
    }
    errno = tp_enqueueImmediate(threadPool, &userInputTask);
    if (errno != 0) {
      fprintf(stderr, "Unable to user input task to threadpool in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      handleExitError(errno);
    }

    // ========== LIST OF RUNNING CATERPILLARS =============
    pthread_mutex_t runningCatLock;
    errno = pthread_mutex_init(&runningCatLock, NULL);
    if (errno != 0) {
      fprintf(stderr, "Unable initialize running caterpillar lock in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      handleExitError(errno);
    }
    registerRunningCatLockForBullets(&runningCatLock);
    List runningCaterpillars = list_constructEmpty(sizeof(Task *));
    runningCaterpillars.elementDeleter = destroyCaterpillarTask;
    registerCaterpillarsForBullets(&runningCaterpillars);

    // ========== LIST OF KILLED CATERPILLARS =============
    pthread_mutex_t killedCatLock;
    errno = pthread_mutex_init(&killedCatLock, NULL);
    if (errno != 0) {
      fprintf(stderr, "Unable initialize killed caterpillar lock in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      list_freeNodes(&runningCaterpillars);
      pthread_mutex_destroy(&killedCatLock);
      handleExitError(errno);
    }
    registerKilledCatLockForBullets(&killedCatLock);
    List killedCaterpillars = list_constructEmpty(sizeof(Task *));
    registerKilledCaterpillarsForBullets(&killedCaterpillars);
    killedCaterpillars.elementDeleter = destroyCaterpillarTask;

    // ========== CATERPILLAR SPAWNING THREAD =============
    Task spawnCatsTask;
    void *spawnCatsResult;
    SpawnCaterpillarsArg spawnCatsArg = {
        .runningCatLock = &runningCatLock,
        .runningCaterpillars = &runningCaterpillars,
        .killedCatLock = &killedCatLock,
        .killedCaterpillars = &killedCaterpillars,
        .threadPool = threadPool,
        .sleepGame = &sleepGame};
    errno = task_init(&spawnCatsTask, spawnCaterpillars, &spawnCatsArg,
                      &spawnCatsResult);
    if (errno != 0) {
      fprintf(stderr, "Unable initialize spawn caterpillar task in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      list_freeNodes(&runningCaterpillars);
      pthread_mutex_destroy(&killedCatLock);
      list_freeNodes(&killedCaterpillars);
      task_destroy(&spawnCatsTask);
      handleExitError(errno);
    }
    errno = tp_enqueueImmediate(threadPool, &spawnCatsTask);
    if (errno != 0) {
      fprintf(stderr,
              "Unable to add spawn caterpillar task to threadpool in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      list_freeNodes(&runningCaterpillars);
      pthread_mutex_destroy(&killedCatLock);
      list_freeNodes(&killedCaterpillars);
      task_destroy(&spawnCatsTask);
      handleExitError(errno);
    }

    // ========== UPKEEP THREAD =============
    Task upkeepTask;
    void *upkeepResult;
    UpkeepArg upkeepArg = {.p = &p,
                           .killedCatLock = &killedCatLock,
                           .killedCaterpillars = &killedCaterpillars,
                           .banner = &banner,
                           .sleepGame = &sleepGame};
    errno = task_init(&upkeepTask, runUpkeep, &upkeepArg, &upkeepResult);
    if (errno != 0) {
      fprintf(stderr, "Unable to initialize upkeep task in %s\n", fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      list_freeNodes(&runningCaterpillars);
      pthread_mutex_destroy(&killedCatLock);
      list_freeNodes(&killedCaterpillars);
      task_destroy(&spawnCatsTask);
      task_destroy(&upkeepTask);
      handleExitError(errno);
    }
    errno = tp_enqueueImmediate(threadPool, &upkeepTask);
    if (errno != 0) {
      fprintf(stderr, "Unable to add upkeep task to threadpool in %s\n",
              fooName);
      task_destroy(&sleepGame);
      destroyPlayer(&p);
      task_destroy(&playerTask);
      task_destroy(&screenRefresherTask);
      task_destroy(&userInputTask);
      pthread_mutex_destroy(&runningCatLock);
      list_freeNodes(&runningCaterpillars);
      pthread_mutex_destroy(&killedCatLock);
      list_freeNodes(&killedCaterpillars);
      task_destroy(&spawnCatsTask);
      task_destroy(&upkeepTask);
      handleExitError(errno);
    }

    // ========== SLEEP GAME WHILE RUNNING =============
    // Sleep current thread until game completion using Task
    //  task_getResult will sleep until task_markComplete is called
    task_getResult(&sleepGame);
    task_destroy(&sleepGame);

    putBanner(banner);

    // ========== FINISH TASKS AND GET RESULTS =============
    task_getResult(&playerTask);
    task_getResult(&screenRefresherTask);
    task_getResult(&userInputTask);
    task_getResult(&upkeepTask);
    task_getResult(&spawnCatsTask);

    // ========== DESTROY GAME VARIABLES =============
    task_destroy(&playerTask);
    task_destroy(&upkeepTask);
    task_destroy(&screenRefresherTask);
    task_destroy(&userInputTask);
    task_destroy(&spawnCatsTask);

    destroyPlayer(&p);
    list_freeNodes(&runningCaterpillars);
    list_freeNodes(&killedCaterpillars);
    pthread_mutex_destroy(&runningCatLock);
    pthread_mutex_destroy(&killedCatLock);

    finalKeypress(); /* wait for final key before killing curses and game */
  }

  gameConsoleFinish();
}
/**
 * @file game_console.c
 * @author Justen Di Ruscio
 * @brief Definitions that wrap distribute/console
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#define _GNU_SOURCE

#include <caterpillar/game/game_console.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include "../distribute/console.h"
#include <caterpillar/game/constants.h>

#define REFRESH_SLEEP_TICKS 4

pthread_mutex_t consoleMutex;

// ======================= Public Console Functions ========================
bool gameConsoleInit() {
  const char fooName[] = "gameConsoleInit";

  const bool success = consoleInit(GAME_ROWS, GAME_COLS, GAME_BOARD);
  if (!success) {
    return false;
  }
  errno = pthread_mutex_init(&consoleMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Error while trying to initialize console mutex in %s\n",
            fooName);
    return false; // errno set by pthread_mutex_init
  }

  // Initialize recursive mutex to lock console
  pthread_mutexattr_t mutexAttrs;
  errno = pthread_mutexattr_init(&mutexAttrs);
  if (errno != 0) {
    fprintf(stderr, "Failed to initialize mutex attributes for console in %s\n",
            fooName);
    return false;
  }
  pthread_mutexattr_settype(&mutexAttrs, PTHREAD_MUTEX_RECURSIVE);
  if (errno != 0) {
    fprintf(stderr, "Failed to set mutex attributes for console in %s\n",
            fooName);
    return false;
  }
  errno = pthread_mutex_init(&consoleMutex, &mutexAttrs);
  if (errno != 0) {
    fprintf(stderr, "Failed to initialize mutex for console in %s\n", fooName);
    return false;
  }
  errno = pthread_mutexattr_destroy(&mutexAttrs);
  if (errno != 0) {
    fprintf(stderr, "Failed to destroy mutex attributes in %s\n", fooName);
    return false;
  }
  return true;
}

int gameConsoleFinish() {
  const char fooName[] = "gameConsoleFinish";
  const int err = pthread_mutex_destroy(&consoleMutex);
  putBanner("Done");
  consoleFinish();
  if (err != 0) {
    errno = err;
    fprintf(stderr, "Error while destroying console mutex in %s\n", fooName);
  }
  return errno;
}

// ================== Screen Refresh Thread Start Function ====================
void *runScreenRefresher(void *data) {
  const char fooName[] = "runScreenRefresher";
  const RefreshArg *const arg = (RefreshArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr, "argument 'data' of %s must point to a valid RefreshArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  }

  // Draw screen buffer to screen
  else {
    while (!arg->sleepGame->completed) {
      // hold lock to prevent tearing on screen
      errno = pthread_mutex_lock(&consoleMutex);
      if (errno != 0) {
        fprintf(
            stderr,
            "Error encountered while trying to obtain lock to refresh screen "
            "in %s\n",
            fooName);
        break;
      }

      consoleRefresh();

      errno = pthread_mutex_unlock(&consoleMutex);
      if (errno != 0) {
        fprintf(
            stderr,
            "Error encountered while trying to release lock after refreshing "
            "screen in %s\n",
            fooName);
        break;
      }
      sleepTicks(REFRESH_SLEEP_TICKS);
    }
  }

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }
  return (void *)(size_t)errno;
}
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <jd/threadpool.h>

#include "../../distribute/console.h"
#include <caterpillar/game/game.h>

#define NUM_INIT_THREADS 16
#define INSTRUCTIONS_SLEEP_TICKS 150

void printInstructions() {
  printf(
      "======== INSTRUCTIONS ========\n"
      "w - move up\n"
      "a - move left\n"
      "s - move down\n"
      "d - move right\n"
      "space - shoot\n"
      "Hit a caterpillar and it will split into two or die if it's too short.\n"
      "Kill all caterpillars to win game.\n");
}

int main() {
  srand(time(0));
  ThreadPool tp;
  tp_init(&tp, NUM_INIT_THREADS);

  printInstructions();
  sleepTicks(INSTRUCTIONS_SLEEP_TICKS);
  caterpillarRun(&tp);

  tp_destroy(&tp);
  return EXIT_SUCCESS;
}
/**
 * @file upkeep.c
 * @author Justen Di Ruscio
 * @brief Upkeep game definitions
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/upkeep.h>

#include <errno.h>
#include <stdbool.h>
#include <stdio.h>

#include <caterpillar/bullets/registry.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>

#define UPKEEP_TICKS 100

// ========================== Support Functions ============================
/**
 * @brief Writes the provided score to the score board. sets errno upon error
 *
 * @param score score to write to game board
 * @return true successfully wrote score to board
 * @return false error occurred; errno set too
 */
static bool writeScoreToBoard(const int score) {
  const char fooName[] = "writeScoreToBoard";

  char scoreStr[SCORE_MAX_LENGTH];
  const int num = snprintf(scoreStr, SCORE_MAX_LENGTH, "%i", score);
  if (num < 0) {
    fprintf(stderr, "Failure converting player's score to string in %s\n",
            fooName);
    errno = EIO;
    return false;
  }
  char *img = &scoreStr[0];
  consoleClearImage(SCORE_ROWS, SCORE_COLS, 1, SCORE_MAX_LENGTH);
  consoleDrawImage(SCORE_ROWS, SCORE_COLS, &img, 1);
  return true;
}

/**
 * @brief Writes the provided lives to the score board. sets errno upon error
 *
 * @param lives lives to write to game board
 * @return true successfully wrote lives to board
 * @return false error occurred; errno set too
 */
static bool writeLivesToBoard(const int lives) {
  const char fooName[] = "writeLivesToBoard";

  char livesStr[LIFE_MAX_LENGTH];
  const int num = snprintf(livesStr, LIFE_MAX_LENGTH, "%i", lives);
  if (num < 0) {
    fprintf(stderr, "Failure converting player's lives to string in %s\n",
            fooName);
    errno = EIO;
    return false;
  }
  char *img = &livesStr[0];
  consoleClearImage(LIFE_ROWS, LIFE_COLS, 1, LIFE_MAX_LENGTH);
  consoleDrawImage(LIFE_ROWS, LIFE_COLS, &img, 1);
  return true;
}

// ====================== Upkeep Thread Start Function ========================
void *runUpkeep(void *data) {
  const char fooName[] = "runUpkeep";
  const UpkeepArg *const arg = (UpkeepArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr, "argument 'data' of %s must point to a valid UpkeepArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->p == (Player *)NULL) {
    fprintf(stderr,
            "member 'p' of argument 'data' of %s must point to the current "
            "player\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCatLock == (pthread_mutex_t *)NULL) {
    fprintf(stderr,
            "member 'killedCatLock' of argument 'data' of %s must point to the "
            "lock for killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->killedCaterpillars == (List *)NULL) {
    fprintf(stderr,
            "member 'killedCaterpillars' of argument 'data' of %s must point "
            "to the list of killed caterpillars\n",
            fooName);
    errno = EPERM;
  } else if (arg->banner == (char **)NULL) {
    fprintf(stderr,
            "member 'banner' of argument 'data' of %s must point to a valid "
            "address\n",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  }

  // Upkeep game
  else {
    while (!arg->sleepGame->completed) {
      // Draw images to curses screen buffer
      errno = pthread_mutex_lock(&consoleMutex);
      if (errno != 0) {
        fprintf(
            stderr,
            "Encountered error trying to obtain console lock to draw image to "
            "game board in %s\n",
            fooName);
        break;
      }

      bool success = writeScoreToBoard(arg->p->score);
      if (!success) {
        fprintf(stderr, "Failure writing player's score to game board in %s\n",
                fooName);
        break; // errno set by writeScoreToBoard
      }
      success = writeLivesToBoard(arg->p->lives);
      if (!success) {
        fprintf(stderr, "Failure writing player's lives to game board in %s\n",
                fooName);
        break; // errno set by writeLivesToBoard
      }

      errno = pthread_mutex_unlock(&consoleMutex);
      if (errno != 0) {
        fprintf(
            stderr,
            "Encountered error trying to release console lock after drawing "
            "image to game board in %s\n",
            fooName);
        break;
      }

      // Destroy all the killed caterpillars
      errno = pthread_mutex_lock(arg->killedCatLock);
      if (errno != 0) {
        fprintf(stderr, "Unable to lock list of killed caterpillars in %s\n",
                fooName);
        break;
      }

      list_freeNodes(arg->killedCaterpillars);

      errno = pthread_mutex_unlock(arg->killedCatLock);
      if (errno != 0) {
        fprintf(stderr, "Unable to unlock list of killed caterpillars in %s\n",
                fooName);
        break;
      }

      // Check if Player won
      errno = pthread_mutex_lock(registry.runningCatLock);
      if (errno != 0) {
        fprintf(stderr, "Unable to lock list of running caterpillars in %s\n",
                fooName);
        break;
      }

      if (registry.runningCaterpillars->length == 0) {
        errno = task_markCompleted(arg->sleepGame);
        if (errno != 0) {
          fprintf(stderr, "Failure completing game in %s\n", fooName);
          break;
        }
        *arg->banner = "DONE - WIN";
      }

      errno = pthread_mutex_unlock(registry.runningCatLock);
      if (errno != 0) {
        fprintf(stderr, "Unable to unlock list of running caterpillars in %s\n",
                fooName);
        break;
      }

      sleepTicks(UPKEEP_TICKS);
    }
  }

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }

  return (void *)(size_t)errno;
}
/**
 * @file player.c
 * @author Justen Di Ruscio
 * @brief Definitions related to caterpillar game player, including space ship
 * on screen
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/user/player.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include <caterpillar/bullets/bullet.h>
#include <caterpillar/bullets/bullet_collisions.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>

// ========================== Global Constants ============================
#define PLAYER_ANIM_TILES 3
#define PLAYER_ANIM_TICKS 50

char *playerGraphic[PLAYER_ANIM_TILES][PLAYER_HEIGHT] = {
    {"/o\\", "|||", "/^\\"}, {"/|\\", "|o|", "/^\\"}, {"/|\\", "|||", "/*\\"}};

const int lowerBound = SCR_TOP + GAME_ROWS - PLAYER_HEIGHT;
const int upperBound = SCR_TOP + BOUNDARY_ROW + DOWN;
const int leftBound = SCR_LEFT;
const int rightBound = SCR_LEFT + GAME_COLS - PLAYER_WIDTH;

// ========================== Support Functions ============================
/**
 * @brief Resets player to start location
 *
 * @param p player
 * @return int errno
 */
static int resetPlayer(Player *const p) {
  const char fooName[] = "resetPlayer";

  // Argument Validity Check
  errno = 0;
  if (p == (Player *)NULL) {
    fprintf(stderr, "argument 'p' of %s must point to the current player\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Reset Player
  p->row = p->startRow;
  p->col = p->startCol;
  p->animTile = PLAYER_ANIM_TILES - 1;
  p->state = GAME;
  return errno;
}

/**
 * @brief Redraws player on consol at provided location
 *
 * @param p player
 * @param row
 * @param col
 * @return int errno
 */
static int redrawPlayer(const Player *const p, const int row, const int col) {
  const char fooName[] = "playerRedraw";

  // Argument Validity Check
  errno = 0;
  if (p == (Player *)NULL) {
    fprintf(stderr, "argument 'p' of %s must point to a valid Player\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Draw moved player on game board
  errno = pthread_mutex_lock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to obtain lock before drawing player to screen "
            "in %s\n",
            fooName);
    return errno;
  }

  char **playerImg = playerGraphic[p->animTile];
  consoleClearImage(p->row, p->col, PLAYER_HEIGHT, PLAYER_WIDTH);
  consoleDrawImage(row, col, playerImg, PLAYER_HEIGHT);

  errno = pthread_mutex_unlock(&consoleMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to release lock after drawing player to screen "
            "in %s\n",
            fooName);
  }
  return errno;
}

/**
 * @brief Limits provided location to player boundar
 *
 * @param row
 * @param col
 */
static void clampLocation(int *const row, int *const col) {
  const char fooName[] = "clampPlayerLocation";

  // Argument Validity Checks
  errno = 0;
  if (row == (int *)NULL) {
    fprintf(stderr, "argument 'row' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
  }
  if (col == (int *)NULL) {
    fprintf(stderr, "argument 'col' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
  }

  // Clamp row to player's vertical boundaries
  if (*col < leftBound) {
    *col = leftBound;
  } else if (*col > rightBound) {
    *col = rightBound;
  }

  // Clamp col to player's horizontal boundaries
  if (*row < upperBound) {
    *row = upperBound;
  } else if (*row > lowerBound) {
    *row = lowerBound;
  }
}

// ======================== Public Player Functions =========================
int initPlayer(Player *const p, const int startRow, const int startCol,
               const int lives) {
  const char fooName[] = "initPlayer";

  // Argument Validity Check
  errno = 0;
  if (p == (Player *)NULL) {
    fprintf(stderr, "argument 'p' of %s must point to the current player\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Initialize player
  p->lives = lives;
  p->score = 0;
  p->startRow = startRow;
  p->startCol = startCol;
  p->shotBullets = list_constructEmpty(sizeof(Task *));
  p->shotBullets.elementDeleter = deleteBulletTask;

  errno = resetPlayer(p);
  if (errno != 0) {
    fprintf(stderr, "Unable to reset player in %s\n", fooName);
    return errno;
  }

  errno = pthread_mutex_init(&p->locationMutex, NULL);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to initialize player's location mutex in %s\n",
            fooName);
    return errno;
  }
  errno = pthread_mutex_init(&p->stateMutex, NULL);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to initialize player's state mutex in %s\n",
            fooName);
    return errno;
  }
  errno = pthread_mutex_init(&p->bulletMutex, NULL);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to initialize player's bullet mutex in %s\n",
            fooName);
  }
  return errno;
}

int destroyPlayer(Player *const p) {
  const char fooName[] = "destroyPlayer";
  errno = 0;

  // Return if there's nothing to destroy
  if (p == (Player *)NULL) {
    return errno;
  }

  // Destroy Player
  errno = pthread_mutex_destroy(&p->locationMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to destroy player's bullet mutex in %s\n",
            fooName);
  }
  errno = pthread_mutex_destroy(&p->stateMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to destroy player's bullet mutex in %s\n",
            fooName);
  }
  errno = pthread_mutex_destroy(&p->bulletMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while trying to destroy player's bullet mutex in %s\n",
            fooName);
  }
  list_freeNodes(&p->shotBullets);
  return errno;
}

int movePlayer(Player *const p, int row, int col, const bool lock) {
  const char fooName[] = "movePlayer";

  // Argument Validity Check
  errno = 0;
  if (p == (Player *)NULL) {
    fprintf(stderr, "argument 'p' of %s must point to the current player\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Move Player
  // restrict location
  clampLocation(&row, &col);

  // draw player and update location
  if (lock) {
    errno = pthread_mutex_lock(&p->locationMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Unable to lock player's location mutex before moving in %s\n",
              fooName);
      return errno;
    }
  }

  errno = redrawPlayer(p, row, col);
  if (errno != 0) {
    fprintf(stderr, "Encountered error drawing player to game console in %s\n",
            fooName);
  }
  p->row = row;
  p->col = col;

  if (lock) {
    errno = pthread_mutex_unlock(&p->locationMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Unable to unlock player's location mutex after moving in %s\n",
              fooName);
    }
  }

  return errno;
}

// ====================== Player Thread Start Function ========================
void *runPlayer(void *data) {
  const char fooName[] = "runPlayer";
  RunPlayerArg *const arg = (RunPlayerArg *)data;
  Player *const player = arg->p;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr,
            "argument 'data' of %s must point to a valid RunPlayerArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->p == (Player *)NULL) {
    fprintf(stderr,
            "member 'p' of argument 'data' of %s must point to the current "
            "player\n",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  }

  // Move Player Around Screen
  else {
    while (!arg->sleepGame->completed && player->lives >= 0) {
      switch (player->state) {
      case DEAD:
        player->lives--;
        if (player->lives == 0) {
          // quit game
        }
        break;
      default:;
      }

      ++player->animTile;
      player->animTile %= PLAYER_ANIM_TILES;
      errno = redrawPlayer(player, player->row, player->col);
      if (errno != 0) {
        fprintf(stderr, "Error trying to draw player to console buffer in %s\n",
                fooName);
        break;
      }

      sleepTicks(PLAYER_ANIM_TICKS);
    }
  }

  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }

  return (void *)(size_t)errno;
}
/**
 * @file player_state.c
 * @author Justen Di Ruscio
 * @brief Definitions related to updating player state
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <caterpillar/user/player_state.h>

#include <errno.h>
#include <stdio.h>

int updatePlayerLives(Player *const p, const int offset, int *const lives) {
  const char fooName[] = "updatePlayerLives";

  // Argument Validity Check
  if (p == (Player *)NULL) {
    fprintf(
        stderr,
        "argument 'p' of updatePlayerLives must point to the current player\n");
    errno = EPERM;
    return errno;
  }

  // Update Player's lives
  errno = pthread_mutex_lock(&p->stateMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure locking Player's state mutex in %s\n", fooName);
    return errno;
  }

  p->lives += offset;
  *lives = p->lives;

  errno = pthread_mutex_unlock(&p->stateMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure unlocking Player's state mutex in %s\n", fooName);
  }
  return errno;
}

int updatePlayerScore(Player *const p, const int offset) {
  const char fooName[] = "updatePlayerLives";

  // Argument Validity Check
  if (p == (Player *)NULL) {
    fprintf(
        stderr,
        "argument 'p' of updatePlayerLives must point to the current player\n");
    errno = EPERM;
    return errno;
  }

  // Update Player's lives
  errno = pthread_mutex_lock(&p->stateMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure locking Player's state mutex in %s\n", fooName);
    return errno;
  }

  p->score += offset;

  errno = pthread_mutex_unlock(&p->stateMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure unlocking Player's state mutex in %s\n", fooName);
  }
  return errno;
}
/**
 * @file user_input.c
 * @author Justen Di Ruscio
 * @brief Definitions related to accepting user input to control player
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#define _POSIX_C_SOURCE 199309L

#include <caterpillar/user/user_input.h>

#include <errno.h>
#include <stdio.h>
#include <sys/select.h>
#include <time.h>
#include <unistd.h>

#include <caterpillar/bullets/bullet.h>
#include <caterpillar/game/constants.h>
#include <caterpillar/game/game_console.h>
#include <caterpillar/user/player.h>

// ========================== Command Declarations ============================
// available input commands. same order as inputCmdChars
typedef enum Command {
  cmd_Up,
  cmd_Left,
  cmd_Down,
  cmd_Right,
  cmd_FireBullet,
  cmd_Unknown
} Command;
// input command types
typedef enum CmdType { cmdType_Bullet, cmdType_Move, cmdType_Unknown } CmdType;

// ========================== Global Constants ============================
#define NSEC_TO_SEC 1000000000    // conversion ratio
#define INPUT_TIMEOUT_USEC 200000 // micro-seconds duration to timeout input
// input chars which associate to commands
const char inputCmdChars[] = {'w', 'a', 's', 'd', ' '};
const int inputCmdsLength = 5;
// mapping of Command (index) to command type. Same order as inputCmdChars
const CmdType commandTypes[] = {cmdType_Move, cmdType_Move,   cmdType_Move,
                                cmdType_Move, cmdType_Bullet, cmdType_Unknown};

// ========================== Support Functions ============================
/**
 * @brief Returns the Command identified by inputCmd
 *
 * @param inputCmd character to find in inputCmdChars; user provided input
 * command
 * @return Command the identified command
 */
static Command getCommand(const char inputCmd) {
  int index = cmd_Unknown;
  for (int i = 0; i < inputCmdsLength; ++i) {
    if (inputCmdChars[i] == inputCmd) {
      index = i;
      break;
    }
  }
  return (Command)index;
}

/**
 * @brief Reads character from stdin. Places its respective Command in cmd.
 * errno set on error
 *
 * @param cmd pointer to command in which identified command will be placed
 * @return true successfully read command from stdin
 * @return false error occurred; errno set, too
 */
static bool readUserCmd(Command *const cmd) {
  const char fooName[] = "readUserCmd";
  char inputChar;
  scanf("%c", &inputChar);
  if (errno != 0) {
    fprintf(stderr,
            "Input scanning error while trying to read user input in %s\n",
            fooName);
    return false;
  }
  *cmd = getCommand(inputChar);
  return true;
}

static double timespecToSec(const struct timespec t) {
  double secs = (double)t.tv_sec;
  secs += (double)t.tv_nsec / NSEC_TO_SEC;
  return secs;
}

static int executeCommand(const Command cmd, Player *const p,
                          double *const lastMoveInstant,
                          double *const lastBulletInstant) {
  const char fooName[] = "executeCommand";

  // Argument Validity Check
  errno = 0;
  if (p == (Player *)NULL) {
    fprintf(stderr, "argument 'p' of %s must point to the current player\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Execute command if it's known
  if (cmd != cmd_Unknown) {
    // Skip command if executing would exceed max rate
    double *lastExInstant = lastMoveInstant;
    double minCmdDuration = MOVE_MIN_SECS;
    const CmdType cmdType = commandTypes[(int)cmd];
    if (cmdType == cmdType_Bullet) {
      lastExInstant = lastBulletInstant;
      minCmdDuration = BULLET_MIN_SECS;
    }
    struct timespec t;
    const int err = clock_gettime(CLOCK_MONOTONIC, &t);
    if (err < 0) {
      fprintf(stderr, "Failure getting time with clock_gettime in %s\n",
              fooName);
      return errno; // errno set by clock_gettime
    }
    const double currentCmdInstant = timespecToSec(t);
    const double duration = currentCmdInstant - *lastExInstant;
    if (duration >= minCmdDuration) {
      *lastExInstant = currentCmdInstant;
    } else {
      return 0;
    }

    // Execute corresponding command
    char *errMsg;
    switch (cmd) {
    case cmd_Up:
      errno = movePlayer(p, p->row + UP, p->col, true);
      if (errno != 0) {
        errMsg = "move player up";
      }
      break;
    case cmd_Down:
      errno = movePlayer(p, p->row + DOWN, p->col, true);
      if (errno != 0) {
        errMsg = "move player down";
      }
      break;
    case cmd_Left:
      errno = movePlayer(p, p->row, p->col + LEFT, true);
      if (errno != 0) {
        errMsg = "move player left";
      }
      break;
    case cmd_Right:
      errno = movePlayer(p, p->row, p->col + RIGHT, true);
      if (errno != 0) {
        errMsg = "move player left";
      }
      break;
    case cmd_FireBullet:
      errno = shootBullet(p->row, p->col + (PLAYER_WIDTH >> 1), b_Player, p);
      if (errno != 0) {
        errMsg = "fire player's bullet";
      }
      break;
    default:;
    }

    if (errno != 0) {
      fprintf(stderr, "Error trying to execute command to %s in %s\n", errMsg,
              fooName);
    }
  }
  return errno;
}

// ==================== User Input Thread Start Function ======================
void *acceptUserInput(void *data) {
  const char fooName[] = "acceptUserInput";
  const UserInputArg *const arg = (UserInputArg *)data;

  // Argument Validity Checks
  errno = 0;
  if (data == (void *)NULL) {
    fprintf(stderr, "argument 'data' of %s must point to a valid UpkeepArg\n",
            fooName);
    errno = EPERM;
  } else if (arg->p == (Player *)NULL) {
    fprintf(stderr,
            "member 'p' of argument 'data' of %s must point to the current "
            "player\n",
            fooName);
    errno = EPERM;
  } else if (arg->sleepGame == (Task *)NULL) {
    fprintf(stderr,
            "member 'sleepGame' of argument 'data' of %s must point to the "
            "main Task used to sleep the game\n",
            fooName);
    errno = EPERM;
  }

  // Accept user's input and act on it
  else {
    // command rate limiting
    double lastMoveInstantSecs;   // when last move command was executed
    double lastBulletInstantSecs; // when last bullet was executed

    // user input reading
    fd_set readfds;              // set of file descriptors for select to watch
    struct timeval inputTimeout; // timeout interval to stop waiting for input
                                 // and check if game completed

    // Continuously read user input and execute commands
    while (!arg->sleepGame->completed) {
      // order select to wait for input on stdin (fd 0)
      FD_ZERO(&readfds); // init rfds to null set
      FD_SET(STDIN_FILENO, &readfds);

      // order select to timeout after 0.5 sec
      inputTimeout.tv_sec = 0;
      inputTimeout.tv_usec = INPUT_TIMEOUT_USEC;

      // Wait for input to become present on stdin
      // readfds & inputTimeout modified by select
      const int numSetBits =
          select(STDIN_FILENO + 1, &readfds, NULL, NULL, &inputTimeout);
      if (numSetBits < 0) {
        fprintf(
            stderr,
            "Failure in %s waiting for input to become available on stdin\n",
            fooName);
        break; // errno set by select
      }

      // Input is present on stdin -> read input and execute command
      if (FD_ISSET(STDIN_FILENO, &readfds)) {
        // consume char from stdin, identifying its associated command
        Command inputCmd;
        const bool success = readUserCmd(&inputCmd);
        if (!success) {
          fprintf(stderr, "Failure reading usr input command in %s\n", fooName);
          break; // errno set by readUserCmd
        }

        // execute input char's corresponding command
        errno = executeCommand(inputCmd, arg->p, &lastMoveInstantSecs,
                               &lastBulletInstantSecs);
        if (errno != 0) {
          fprintf(stderr,
                  "Error in %s while executing command for user input %c\n",
                  fooName, inputCmdChars[(int)inputCmd]);
          break;
        }
      }
    }
  }

  // Stop game if error occurred
  if (errno != 0) {
    const int err = task_markCompleted(arg->sleepGame);
    if (err != 0) {
      fprintf(stderr, "Error while trying to mark game as completed in %s\n",
              fooName);
    }
  }

  return (void *)(size_t)errno;
}
#pragma once
/**
 * @file bullet_list.h
 * @author Justen Di Ruscio
 * @brief Contains functions that are used to manage lists of bullets
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/list.h>

#include <caterpillar/bullets/bullet.h>

/**
 * @brief erases all caterpillar and player bullets
 *
 * @return int errno
 */
int eraseAllBullets();

/**
 * @brief erases the provided bullet node from the provided shooter's list. Sets errno on error
 *
 * @param shooter either a Caterpillar or Player
 * @param bulletNode bullet node from Caterpillar or Player list to delete
 * @param type type of bullet in bulletNode
 * @param lock flag to lock shooter's bullet mutex or not
 * @return int errno
 */
int eraseBulletFromShooterList(void *const shooter, ListNode *const bulletNode,
                               const BulletType type, const bool lock);

/**
 * @brief Adds the provided bullet node to the provided shooter's list of bullets. Sets errno on error
 *
 * @param shooter either a Player or Caterpillar
 * @param bulletNode bullet node to add to list
 * @param type type of bullet in bulletNode
 * @return int errno
 */
int addBulletToShooterList(void *const shooter, ListNode *const bulletNode,
                           const BulletType type);
#pragma once

#include <pthread.h>
#include <stdbool.h>

#include <jd/threadpool.h>

bool tp_spawnThread(ThreadPool* const tp);

void *workerFunction(void* tp);
#pragma once
/**
 * @file vector_private.h
 * @author Justen Di Ruscio (3624673)
 * @brief Contains symbols for functions pertaining to Vectors which aren't
 * necessary as part of their public interface.
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/vector.h>

/**
 * @brief Assigns the value of numElements elements in vec starting at
 * destination to the values of the contiguous elements pointed to by source.
 * Assigns errno upon error.
 *
 * @param vec Vector to assign elements in
 * @param destination index of first element to assign in vec
 * @param numElements number of elements pointed to by source and to assign.
 * @param source contiguous elements whose contents will be copied into elements
 * of vec
 * @return true successfully assigned elements
 * @return false failed to assign elements
 */
static bool vector_assignElements(Vector* const vec, const size_t destination,
                                  const size_t numElements, const void* source);
/**
 * @file error.c
 * @author Justen Di Ruscio (3624673)
 * @brief Contains definitions for common error handling/checking functions
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/error.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void handleErrorMsg(const int errorNumber) {
  const char *errorString = strerror(errorNumber);
  if (errorString == (char *)NULL) {
    errorString =
        "Invalid error number. Cannot deduce error message from error number";
  }
  fprintf(stderr, "(pid=%i) error = %i - %s\n", getpid(), errorNumber,
          errorString);
}

void handleExitError(const int errorNumber) {
  handleErrorMsg(errorNumber);
  exit(errorNumber);
}

bool memoryOverlaps(const void *const first, const void *const second,
                    const unsigned dataSize) {
  const char *firstBytes = (char *)first;
  const char *secondBytes = (char *)second;
  const bool firstOverlapsSecond =
      firstBytes <= secondBytes && firstBytes + dataSize > secondBytes;
  const bool secondOverlapsFirst =
      secondBytes <= firstBytes && secondBytes + dataSize > firstBytes;
  return firstOverlapsSecond || secondOverlapsFirst;
}
/**
 * @file list.c
 * @author Justen Di Ruscio (3624673)
 * @brief Definitions for doubly linked list and functions to modify it.
 * Doesn't use pool allocator but instead allocates each node individually
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/list.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

List list_constructEmpty(const size_t dataSize) {
  List result = {.head = (void *)NULL,
                 .tail = (void *)NULL,
                 .length = 0,
                 .dataSize = dataSize,
                 .elementDeleter = NULL};
  return result;
}

OptionalList list_copyConstruct(const List *const other) {
  const char fooName[] = "list_copyConstruct";
  List newList = list_constructEmpty(0);
  OptionalList result = {.list = newList, .valid = false};

  // Argument Validity Check
  errno = 0;
  if (other == (List *)NULL) {
    fprintf(stderr, "field 'other' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Copy Construct
  // list pointers
  newList.dataSize = other->dataSize;
  newList.head = other->head;
  newList.tail = other->tail;
  // nodes
  ListNode *node = other->head;
  while (node != (ListNode *)NULL) {
    const bool pushed = list_pushBack(&newList, node->data);
    if (!pushed) {
      fprintf(stderr, "Unable to push back element in %s\n", fooName);
      return result; // errno set by list_pushBack
    }
    node = node->next;
  }

  result.list = newList;
  result.valid = true;
  return result;
}

void list_freeNodes(List *const list) {
  // Return if there's nothing to free
  if (list == (List *)NULL) {
    return;
  }
  if (list->head == (ListNode *)NULL) {
    return;
  }

  // Free Nodes
  const ListNode *node = list->head;
  while (node != (ListNode *)NULL) {
    const ListNode *const next = node->next;
    list_freeNode(list, node);
    node = next;
  }
  list->head = (ListNode *)NULL;
  list->tail = (ListNode *)NULL;
  list->length = 0;
}

ListNode *list_nodeAt(const List *const list, const size_t index) {
  const char fooName[] = "list_nodeAt";

  // Argument Validity Check
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return (ListNode *)NULL;
  }
  if (index >= list->length) {
    fprintf(stderr,
            "field 'index' (%zu) is too large to index the provided list of "
            "length %zu in %s\n",
            index, list->length, fooName);
    errno = EOVERFLOW;
    return (ListNode *)NULL;
  }

  // Access node at index
  ListNode *node = list->head;
  if (node == (ListNode *)NULL) {
    fprintf(stderr, "Provided list to %s is empty. Cannot access node %zu\n",
            fooName, index);
    errno = EFAULT;
  }
  for (size_t i = 0; i < index; ++i) {
    node = node->next;
    if (node == (ListNode *)NULL) {
      fprintf(
          stderr,
          "list nodes aren't linked by 'next'. Failure to iterate list in %s\n",
          fooName);
      errno = EFAULT;
      break;
    }
  }
  return node;
}

void *list_elementAt(const List *const list, const size_t index) {
  const char fooName[] = "list_elementAt";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return (ListNode *)NULL;
  }
  if (index >= list->length) {
    fprintf(stderr,
            "field 'index' (%zu) is too large to index the provided list of "
            "length %zu in %s\n",
            index, list->length, fooName);
    errno = EOVERFLOW;
    return (ListNode *)NULL;
  }

  // Access element at index
  ListNode *node = list_nodeAt(list, index);
  if (node == (ListNode *)NULL) {
    fprintf(stderr,
            "failure accessing node in linked list at index %zu in %s\n", index,
            fooName);
    return (void *)NULL; // errno set by list_nodeAt
  }
  return node->data;
}

bool list_pushFront(List *const list, const void *const element) {
  const char fooName[] = "list_pushFront";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (element == (void *)NULL) {
    fprintf(stderr, "field 'element' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Push Front
  // allocate new node
  ListNode *newNode = list_newNode(list->dataSize, element);
  if (newNode == (ListNode *)NULL) {
    fprintf(stderr, "Unable to create new node for element in %s\n", fooName);
    return false; // errno set by list_newNode
  }
  // assign to front
  if (list->head != NULL) {
    list->head->prev = newNode;
  } else {
    list->tail = newNode;
  }
  newNode->next = list->head;
  list->head = newNode;
  ++list->length;
  return true;
}

bool list_popFront(List *const list) {
  const char fooName[] = "list_popFront";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Pop Front
  const ListNode *const head = list->head;
  // no nodes; list empty
  if (head == (ListNode *)NULL) {
    errno = EINVAL;
    return false;
  }
  // single node; popping will make empty
  if (head->next == (ListNode *)NULL) {
    list->head = (ListNode *)NULL;
    list->tail = (ListNode *)NULL;
  }
  // multiple nodes in list
  else {
    list->head = head->next;
    list->head->prev = (ListNode *)NULL;
  }

  list_freeNode(list, head);
  --list->length;
  return true;
}

bool list_pushNodeBack(List *const list, ListNode *const node) {
  const char fooName[] = "list_pushNodeBack";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (node == (void *)NULL) {
    fprintf(stderr, "field 'node' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Push Back
  // assign to back
  if (list->tail != (ListNode *)NULL) {
    list->tail->next = node;
  } else {
    list->head = node;
  }
  node->prev = list->tail;
  list->tail = node;
  ++list->length;
  return true;
}

bool list_pushBack(List *const list, const void *const element) {
  const char fooName[] = "list_pushBack";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (element == (void *)NULL) {
    fprintf(stderr, "field 'element' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Push Back
  // allocate new node
  ListNode *newNode = list_newNode(list->dataSize, element);
  if (newNode == (ListNode *)NULL) {
    fprintf(stderr, "Unable to create new node for element in %s\n", fooName);
    return false; // errno set by list_newNode
  }
  return list_pushNodeBack(list, newNode);
}

bool list_popBack(List *const list) {
  const char fooName[] = "list_popBack";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Pop Back
  const ListNode *const tail = list->tail;
  // no nodes; list empty
  if (tail == (ListNode *)NULL) {
    errno = EINVAL;
    return false;
  }
  // single node; popping will make empty
  if (tail->prev == (ListNode *)NULL) {
    list->head = (ListNode *)NULL;
    list->tail = (ListNode *)NULL;
  }
  // multiple nodes in list
  else {
    list->tail = tail->prev;
    list->tail->next = (ListNode *)NULL;
  }

  list_freeNode(list, tail);
  --list->length;
  return true;
}

bool list_insertAt(List *const list, const size_t index,
                   const void *const element) {
  const char fooName[] = "list_insertAt";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (index >= list->length) {
    fprintf(stderr,
            "field 'index' (%zu) is too large to index provided list of length "
            "%zu in %s\n",
            index, list->length, fooName);
    errno = EOVERFLOW;
    return false;
  }
  if (element == (void *)NULL) {
    fprintf(stderr, "field 'element' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Insert
  // push onto front
  if (index == 0) {
    const bool pushed = list_pushFront(list, element);
    if (!pushed) {
      fprintf(stderr, "Failure pushing element into list at index 0 in %s\n",
              fooName);
    }
    return pushed; // errno set by list_pushFront
  }
  // push onto back
  else if (index == list->length - 1) {
    const bool pushed = list_pushBack(list, element);
    if (!pushed) {
      fprintf(stderr, "Failure pushing element into list at index %zu in %s\n",
              list->length - 1, fooName);
    }
    return pushed; // errno set by list_pushBack
  }
  // push somewhere in between
  else {
    // construct new node
    ListNode *const new = list_newNode(list->dataSize, element);
    if (new == (ListNode *)NULL) {
      fprintf(stderr, "Error constructing new node in %s\n", fooName);
      return false; // errno set by list_newNode
    }
    // find location to insert new node
    ListNode *const node = list_nodeAt(list, index);
    if (node == (ListNode *)NULL) {
      fprintf(stderr, "Failure accessing node at index %zu in %s\n", index,
              fooName);
      return false; // errno set by list_nodeAt
    }
    // insert node
    new->next = node;
    new->prev = node->prev;
    node->prev->next = new;
    node->prev = new;
    return true;
  }
}

bool list_eraseAt(List *const list, const size_t index) {
  const char fooName[] = "list_eraseAt";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (index >= list->length) {
    fprintf(stderr,
            "field 'index' (%zu) is too large to index provided list of length "
            "%zu in %s\n",
            index, list->length, fooName);
    errno = EOVERFLOW;
    return false;
  }
  if (list->head == (ListNode *)NULL) {
    fprintf(stderr, "cannot erase from an empty list in %s\n", fooName);
    errno = EPERM;
    return false;
  }

  // Erase node at index
  // erase from front
  if (index == 0) {
    const bool erased = list_popFront(list);
    if (!erased) {
      fprintf(stderr, "Failure erasing element from list at index 0 in %s\n",
              fooName);
    }
    return erased; // errno set by list_popFront
  }
  // erase from back
  else if (index == list->length - 1) {
    const bool erased = list_popBack(list);
    if (!erased) {
      fprintf(stderr, "Failure erasing element from list at index %zu in %s\n",
              list->length - 1, fooName);
    }
    return erased; // errno set by list_popBack
  }
  // erase somewhere in between
  else {
    // find location to erase node
    ListNode *const node = list_nodeAt(list, index);
    if (node == (ListNode *)NULL) {
      fprintf(stderr, "Failure accessing node at index %zu in %s\n", index,
              fooName);
      return false; // errno set by list_nodeAt
    }
    // erase node
    node->prev->next = node->next;
    node->next->prev = node->prev;
    list_freeNode(list, node);
    --list->length;
    return true;
  }
}

bool list_eraseNode(List *const list, ListNode *const node) {
  const char fooName[] = "list_eraseNode";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (node == (ListNode *)NULL) {
    fprintf(stderr, "argument 'node' of %s must point to a valid address\n",
            fooName);
    errno = EOVERFLOW;
    return false;
  }
  if (list->head == (ListNode *)NULL) {
    fprintf(stderr, "cannot erase from an empty list in %s\n", fooName);
    errno = EPERM;
    return false;
  }

  // Erase node
  // erase from front
  if (node == list->head) {
    const bool erased = list_popFront(list);
    if (!erased) {
      fprintf(stderr, "Failure erasing first node from list in %s\n", fooName);
    }
    return erased; // errno set by list_popFront
  }
  // erase from back
  else if (node == list->tail) {
    const bool erased = list_popBack(list);
    if (!erased) {
      fprintf(stderr, "Failure erasing last node from list in %s\n", fooName);
    }
    return erased; // errno set by list_popBack
  }
  // erase somewhere in between
  else {
    // erase node
    node->prev->next = node->next;
    node->next->prev = node->prev;
    list_freeNode(list, node);
    --list->length;
    return true;
  }
}

ListNode *list_newNode(const size_t dataSize, const void *const element) {
  const char fooName[] = "list_newNode";

  // Argument Validity Check
  errno = 0;
  if (dataSize == 0 && element == (void *)NULL) {
    fprintf(stderr,
            "field 'dataSize' in %s must be greater than 0 when an element is "
            "provided\n",
            fooName);
    errno = EPERM;
    return (ListNode *)NULL;
  }

  // Allocate new node
  void *const listNodeBuffer = malloc(sizeof(ListNode) + dataSize);
  if (listNodeBuffer == (void *)NULL) {
    fprintf(stderr, "failure allocating memory for new ListNode in %s\n",
            fooName);
    return (ListNode *)NULL; // errno set by malloc
  }
  ListNode *newNode = (ListNode *)listNodeBuffer;
  newNode->data = (char *)listNodeBuffer + sizeof(ListNode);
  newNode->next = (ListNode *)NULL;
  newNode->prev = (ListNode *)NULL;

  // Copy element contents to new node
  if (element != (void *)NULL) {
    memcpy(newNode->data, element, dataSize);
  }
  return newNode;
}

void list_freeNode(const List *const list, const ListNode *const node) {
  if (list == (List *)NULL) {
    return;
  }
  if (list->elementDeleter != NULL) {
    list->elementDeleter(*(void **)node->data);
  }
  free((ListNode *)node);
}

bool list_containsNode(const List *const list, const ListNode *const node) {
  const char fooName[] = "list_containsNode";
  bool contains = false;

  // Argument Validity Checks
  if (list == (List *)NULL) {
    fprintf(stderr, "argument 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (node == (ListNode *)NULL) {
    fprintf(stderr, "argument 'node' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Find Node
  const ListNode *current = list->head;
  while (current != (ListNode *)NULL) {
    if (current == node) {
      contains = true;
      break;
    }
    current = current->next;
  }
  return contains;
}

bool list_removeNode(List *const list, ListNode *const node) {
  const char fooName[] = "list_removeNode";

  // Argument Validity Checks
  errno = 0;
  if (list == (List *)NULL) {
    fprintf(stderr, "field 'list' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (node == (ListNode *)NULL) {
    fprintf(stderr, "argument 'node' of %s must point to a valid address\n",
            fooName);
    errno = EOVERFLOW;
    return false;
  }
  if (list->head == (ListNode *)NULL) {
    fprintf(stderr, "cannot remove from an empty list in %s\n", fooName);
    errno = EPERM;
    return false;
  }

  // Remove node
  // remove from front
  if (node == list->head) {
    list->head = node->next;
    if (list->head != NULL) {
      list->head->prev = NULL;
    }
  }
  // remove from back
  else if (node == list->tail) {
    list->tail = node->prev;
    if (list->tail != NULL) {
      list->tail->next = NULL;
    }
  }
  // remove somewhere in between
  else {
    node->prev->next = node->next;
    node->next->prev = node->prev;
  }
  node->next = NULL;
  node->prev = NULL;
  --list->length;
  return true;
}
/**
 * @file queue.c
 * @author Justen Di Ruscio
 * @brief Definitions for functions related to queue data structure using linked
 * list
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include "jd/list.h"
#include <jd/queue.h>

Queue q_constructEmpty(const size_t dataSize) {
  Queue q;
  q.elements = list_constructEmpty(dataSize);
  return q;
}

void q_freeElements(Queue *const q) { list_freeNodes(&q->elements); }

bool q_enqueue(Queue *const q, const void *const element) {
  return list_pushBack(&q->elements, element);
}

bool q_dequeue(Queue *const q) { return list_popFront(&q->elements); }

void *q_front(const Queue *const q) { return list_elementAt(&q->elements, 0); }

void *q_back(const Queue *const q) {
  return list_elementAt(&q->elements, q_length(q) - 1);
}

size_t q_length(const Queue *const q) { return q->elements.length; }
/**
 * @file string.c
 * @author Justen Di Ruscio (3624673)
 * @brief Definitions for arbitrary length, null terminated strings and their
 * manipulation. These Strings are not small-string-optimized.
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#define _POSIX_C_SOURCE 200809L

#include <jd/string.h>

#include <stdio.h>  // fprintf
#include <stdlib.h> // malloc

String string_constructEmpty() {
  String result = {.data = (char *)NULL, .length = 0, .capacity = 0};
  return result;
}

OptionalString string_constructCapacity(const size_t capacity) {
  const char fooName[] = "string_constructCapacity";
  String string = string_constructEmpty();
  OptionalString result = {.data = string, .valid = false};

  if (capacity == 0) {
    result.data = string;
    return result;
  }

  void *const newStringBuff = malloc(capacity);
  if (newStringBuff == (void *)NULL) {
    fprintf(stderr, "Error allocating memory for string in %s\n", fooName);
    return result; // errno set by malloc
  }

  string.capacity = capacity;
  string.data = (char *)newStringBuff;
  result.data = string;
  result.valid = true;
  return result;
}

OptionalString string_copyConstruct(const String *const other) {
  const char fooName[] = "string_copyConstruct";
  String string = string_constructEmpty();
  OptionalString result = {.data = string, .valid = false};

  // Argument Validity Check
  errno = 0;
  if (other == (String *)NULL) {
    fprintf(stderr,
            "field 'other' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Copy Construct
  string.length = other->length;
  string.capacity = other->capacity;
  void *const newStringBuff = malloc(string.capacity);
  if (newStringBuff == (void *)NULL) {
    fprintf(stderr, "Unable to allocate memory for string in %s\n", fooName);
    return result; // errno set by malloc
  }
  string.data = (char *)newStringBuff;
  strcpy(string.data, other->data);
  string.data[string.length] = '\0';
  result.valid = true;
  result.data = string;
  return result;
}

OptionalString string_copyConstructChar(const char *const other) {
  const char fooName[] = "string_copyConstructChar";
  String string = string_constructEmpty();
  OptionalString result = {.data = string, .valid = false};

  // Argument Validity Check
  errno = 0;
  if (other == (char *)NULL) {
    fprintf(stderr,
            "field 'other' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Copy Construct
  string.length = strlen(other);
  string.capacity = string.length * 1.5 + 1;
  void *const newStringBuff = malloc(string.capacity);
  if (newStringBuff == (void *)NULL) {
    fprintf(stderr, "Unable to allocate memory for string in %s\n", fooName);
    return result; // errno set by malloc
  }
  string.data = (char *)newStringBuff;
  strcpy(string.data, other);
  string.data[string.length] = '\0';
  result.valid = true;
  result.data = string;
  return result;
}

void string_freeData(const String *const str) {
  // Return if there's nothing to free
  if (str == (String *)NULL) {
    return;
  }
  // Free data member
  free(str->data);
}

void string_freeDataVoid(const void *const str) {
  // Return if there's nothing to free
  if (str == (void *)NULL) {
    return;
  }
  // Free data member
  const String *const string = (String *)str;
  string_freeData(string);
}

bool string_reserve(String *const str, const size_t newCapacity) {
  const char fooName[] = "string_reserve";

  // Argument Validity Checks
  errno = 0;
  if (str == (String *)NULL) {
    fprintf(stderr,
            "field 'str' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Reserve
  if (newCapacity > str->capacity) {
    const void *const newBuffer = realloc(str->data, newCapacity);
    if (newBuffer == (void *)NULL) {
      fprintf(stderr, "Error reserving string buffer with realloc in %s\n",
              fooName);
      return false; // realloc sets errno
    }
    str->data = (char *)newBuffer;
    str->capacity = newCapacity;
  }
  return true;
}

OptionalVector string_split(const String *const str, const char *const delim) {
  const char fooName[] = "string_split";
  OptionalVector result = {.data = {.data = NULL}, .valid = false};

  // Argument Validity Check
  errno = 0;
  if (str == (String *)NULL) {
    fprintf(stderr,
            "field 'str' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }
  if (delim == (char *)NULL) {
    fprintf(stderr,
            "field 'delim' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Split String into Parts

  // create vector to store split string pieces
  const unsigned initialCapacity = 8;
  OptionalVector v = vector_constructCapacity(initialCapacity, sizeof(String));
  if (!v.valid) {
    fprintf(stderr,
            "Unable to construct vector for string pieces with default "
            "capacity of %u in %s\n",
            initialCapacity, fooName);
    return result; // errno set by vector_constructCapacity
  }
  Vector splitStrings = v.data;
  splitStrings.elementDeleter = string_freeDataVoid;

  // tokenize string into pieces, pushing into vector
  char *stringChars = str->data;
  char *savePtr = (char *)NULL;
  while (true) {
    const char *const piece = strtok_r(stringChars, delim, &savePtr);
    if (piece == (char *)NULL) { // no more tokens
      break;
    }
    OptionalString stringPiece = string_copyConstructChar(piece);
    if (!stringPiece.valid) {
      fprintf(stderr, "Unable to construct string from token in %s\n", fooName);
      return result; // errno set by string_copyConstructChar
    }
    const bool pushed = vector_pushBack(&splitStrings, &stringPiece.data);
    if (!pushed) {
      fprintf(stderr,
              "Error pushing string token %s into vector of tokens in %s\n",
              stringPiece.data.data, fooName);
    }
    stringChars = (char *)NULL;
  }

  // return container holding split strings
  result.valid = true;
  result.data = splitStrings;
  return result;
}

int string_compare(const String *const first, const String *const second) {
  return strcmp(first->data, second->data);
}

int string_compareChar(const String *const first, const char *const second) {
  return strcmp(first->data, second);
}

bool string_contains(const String *const string, const char element) {
  const char fooName[] = "string_contains";
  errno = 0;

  // Argument Validity Check
  if (string == (String *)NULL) {
    fprintf(stderr, "argument 'string' of %s must point to a valid string\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Contains
  bool result = false;
  for (size_t listIdx = 0; listIdx < string->length; ++listIdx) {
    if (string->data[listIdx] == element) {
      result = true;
      break;
    }
  }
  return result;
}

OptionalString string_strip(const String *const string,
                            const String *const delimeters) {
  const char fooName[] = "string_strip";
  String stripped = string_constructEmpty();
  OptionalString result = {.data = stripped, .valid = false};

  // Argument Validity Checks
  errno = 0;
  if (string == (String *)NULL) {
    fprintf(stderr, "argument 'string' of %s must point to a valid string\n",
            fooName);
    errno = EPERM;
    return result;
  }
  if (delimeters == (String *)NULL) {
    fprintf(stderr,
            "argument 'delimeters' of %s must point to a valid string\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Strip
  // create iterators on string
  const char *start = string->data;
  const char *last = string->data + string->length - 1;
  // strip from string
  while (start <= last) {
    bool moved = false;
    if (string_contains(delimeters, *start)) {
      ++start;
      moved = true;
    }
    if (string_contains(delimeters, *last)) {
      --last;
      moved = true;
    }
    if (!moved) {
      break;
    }
  }
  // allocate stripped string
  stripped.length = start <= last ? 1 + last - start : 0;
  stripped.capacity = 2 * stripped.length + 1;
  const void *const strippedBuffer = malloc(stripped.capacity);
  if (strippedBuffer == (void *)NULL) {
    return result; // errno set by malloc
  }
  stripped.data = (char *)strippedBuffer;

  // copy contents to new string
  memcpy(stripped.data, start, stripped.length);
  *(stripped.data + stripped.length) = '\0';

  result.data = stripped;
  result.valid = true;
  return result;
}
/**
 * @file task.c
 * @author Justen Di Ruscio
 * @brief Definitions for Task abstraction
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#include <jd/threadpool.h>

#include <errno.h>
#include <stdio.h>

int task_init(Task *const task, void *(*foo)(void *), void *fooArg,
              void **fooReturn) {
  const char fooName[] = "tp_initTask";

  // Argument Validity Checks
  errno = 0;
  if (task == (Task *)NULL) {
    fprintf(stderr, "argument 'task' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }
  if (foo == NULL) {
    fprintf(stderr, "argument 'foo' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Init Provided Task
  task->foo = foo;
  task->fooArg = fooArg;
  task->fooReturn = fooReturn;
  task->fooErrno = 0;
  task->completed = false;

  errno = pthread_cond_init(&task->completedCond, NULL);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to initialize condition variable for task in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_init(&task->completedMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Failure trying to initialize mutex for task in %s\n",
            fooName);
  }

  return errno;
}

int task_destroy(Task *const task) {
  const char fooName[] = "tp_destoryTask";

  // Argument Validity Check
  errno = 0;
  if (task == (Task *)NULL) {
    fprintf(stderr, "argument 'task' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Destory provided Task
  task->foo = NULL;
  task->fooArg = (void *)NULL;
  task->fooReturn = (void *)NULL;
  task->fooErrno = 0;

  // unblock any blocked callers
  errno = pthread_mutex_lock(&task->completedMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to lock task thread while destroying task in %s\n",
            fooName);
    return errno;
  }

  task->completed = true;
  errno = pthread_cond_broadcast(&task->completedCond);
  if (errno != 0) {
    fprintf(stderr, "Failure trying to unblock all callers for task in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_unlock(&task->completedMutex);
  if (errno != 0) {
    fprintf(
        stderr,
        "Failure trying to unlock task thread while destroying task in %s\n",
        fooName);
    return errno;
  }

  // destroy synchronization variables
  errno = pthread_cond_destroy(&task->completedCond);
  if (errno != 0) {
    fprintf(stderr,
            "Failure trying to destroy condition variable for task in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_destroy(&task->completedMutex);
  if (errno != 0) {
    fprintf(stderr, "Failure trying to destroy mutex for task in %s\n",
            fooName);
  }

  return errno;
}

int task_execute(Task *const task) {
  const char fooName[] = "task_execute";

  // Argument Validity Check
  errno = 0;
  if (task == (Task *)NULL) {
    fprintf(stderr, "argument 'task' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Execute function and store result;
  void *result = task->foo(task->fooArg);
  if (task->fooReturn != NULL) {
    *(task->fooReturn) = result;
  }
  task->fooErrno = errno;
  return 0;
}

int task_markCompleted(Task *const task) {
  const char fooName[] = "task_markCompleted";

  // Argument Validity Check
  errno = 0;
  if (task == (Task *)NULL) {
    fprintf(stderr, "argument 'task' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Mark Task completed
  if (task->completed != true) {
    errno = pthread_mutex_lock(&task->completedMutex);
    if (errno != 0) {
      fprintf(
          stderr,
          "Failure while locking task mutex to signal task completed in %s\n",
          fooName);
      return errno;
    }
    task->completed = true;
    errno = pthread_cond_broadcast(&task->completedCond);
    if (errno != 0) {
      fprintf(stderr, "Unable to broadcast completed signal for task in %s\n",
              fooName);
      return errno;
    }
    errno = pthread_mutex_unlock(&task->completedMutex);
    if (errno != 0) {
      fprintf(
          stderr,
          "Failure while locking task mutex to signal task completed in %s\n",
          fooName);
    }
  }
  return errno;
}

int task_getResult(Task *const task) {
  const char fooName[] = "tp_getTaskResult";

  // Argument Validity Check
  if (task == (Task *)NULL) {
    fprintf(stderr, "Argument 'task' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // Wait for result to become available
  errno = pthread_mutex_lock(&task->completedMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Error while attempting to lock task mutex to wait for task "
            "completion in %s\n",
            fooName);
    return errno;
  }
  while (!task->completed) {
    errno = pthread_cond_wait(&task->completedCond, &task->completedMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Encountered error while waiting on task to become available "
              "in %s\n",
              fooName);
      return errno;
    }
  }
  errno = pthread_mutex_unlock(&task->completedMutex);
  if (errno != 0) {
    fprintf(
        stderr,
        "Error while attempting to unlock task mutex after waiting for task "
        "completion in %s\n",
        fooName);
  }
  return errno;
}
/**
 * @file threadpool.c
 * @author Justen Di Ruscio
 * @brief Definitions for expanding thread pool
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#define _GNU_SOURCE

#include <jd/threadpool.h>

#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include "jd/queue.h"
#include "threadpool_private.h"

// ==================== PRIVATE FUNCTIONS ===============
int tp_init(ThreadPool *const tp, const unsigned numInitThreads) {
  const char fooName[] = "tp_init";

  // Argument Validity Check
  errno = 0;
  if (tp == (ThreadPool *)NULL) {
    fprintf(stderr, "argument 'tp' of %s must point to a valid address\n",
            fooName);
  }

  tp->running = true;

  // Initialize condition variable
  errno = pthread_cond_init(&tp->taskAvailable, NULL);
  if (errno != 0) {
    fprintf(stderr,
            "Failed to initialize condition variable for thread pool in %s\n",
            fooName);
    return errno;
  }

  // Initialize mutex for tasks
  errno = pthread_mutex_init(&tp->taskMutex, NULL);
  if (errno != 0) {
    fprintf(stderr, "Failed to initialize task mutex for thread pool in %s\n",
            fooName);
    return errno;
  }

  // Construct empty queue of tasks
  tp->waitingTasks = q_constructEmpty(sizeof(Task *));

  // Construct and store initial threads
  tp->threads = q_constructEmpty(sizeof(pthread_t));
  for (unsigned int threadNum = 0; threadNum < numInitThreads; ++threadNum) {
    const bool spawned = tp_spawnThread(tp);
    if (!spawned) {
      fprintf(stderr, "Failed to spawn new pthread for thread pool in %s\n",
              fooName);
      return errno; // errno set by tp_spawnThread
    }
  }
  tp->numIdleThreads = numInitThreads;

  return errno;
}

bool tp_destroy(ThreadPool *const tp) {
  const char fooName[] = "tp_destroy";

  // Return if there's nothing to destroy
  if (tp == (ThreadPool *)tp) {
    return true;
  }

  // Unblock all threads
  tp->running = false;
  errno = pthread_mutex_lock(&tp->taskMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Failure locking mutex in %s to unblock all threads in pool\n",
            fooName);
    return false;
  }
  const int unblockErr = pthread_cond_broadcast(&tp->taskAvailable);
  errno = pthread_mutex_unlock(&tp->taskMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Failure locking mutex in %s to unblock all threads in pool\n",
            fooName);
    return false;
  }
  if (unblockErr != 0) {
    fprintf(stderr,
            "Failure unblocking all waiting threads with "
            "pthread_cond_broadcast in %s\n",
            fooName);
    errno = unblockErr;
    return false;
  } else {

    // Join all threads from active and idle queues
    for (unsigned tIdx = 0; tIdx < q_length(&tp->threads); ++tIdx) {
      // for each thread in queue
      pthread_t *thread = q_front(&tp->threads);
      if (thread == (pthread_t *)NULL) {
        fprintf(stderr,
                "Unable to read thread from queue of thread pool in %s\n",
                fooName);
        return false; // errno set by q_front
      }
      const bool dequeued = q_dequeue(&tp->threads);
      if (!dequeued) {
        fprintf(stderr,
                "Unable to remove thread from queue of thread pool in %s\n",
                fooName);
        return false; // errno set by q_dequeue
      }
      errno = pthread_join(*thread, NULL);
      if (errno != 0) {
        fprintf(stderr, "Failure joining thread %u from thread queue in %s\n",
                tIdx, fooName);
        return false;
      }
    }

    // Destroy condition variable
    const int err1 = pthread_cond_destroy(&tp->taskAvailable);
    if (errno != 0) {
      fprintf(stderr,
              "Failure destroying thread pool's condition variable in %s\n",
              fooName);
    }

    // Destroy mutexes
    const int err2 = pthread_mutex_destroy(&tp->taskMutex);
    if (errno != 0) {
      fprintf(stderr, "Failure destroying thread pool's task mutex in %s\n",
              fooName);
    }

    errno = err1 != 0 ? err1 : err2;
    return errno == 0;
  }

  // Free Queues
  q_freeElements(&tp->threads);
  q_freeElements(&tp->waitingTasks);
}

// non-reentrant
bool tp_spawnThread(ThreadPool *const tp) {
  const char fooName[] = "tp_spawnThread";

  // Argument Validity Check
  errno = 0;
  if (tp == (ThreadPool *)NULL) {
    fprintf(stderr, "argument 'tp' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  pthread_t thread = 0;

  // Create thread with default attributes
  // thread is joinable (non-detached) by default
  errno = pthread_create(&thread, NULL, workerFunction, tp);
  if (errno != 0) {
    fprintf(stderr, "Failed to create new pthread in %s\n", fooName);
    return false;
  }

  // Store thread in threadpool's queue
  const bool enqueued = q_enqueue(&tp->threads, &thread);
  if (!enqueued) {
    fprintf(stderr, "Failed to add new pthread to thread pool in %s\n",
            fooName);
    return false; // errno set by q_enqueue
  }
  ++tp->numIdleThreads;

  return true;
}

int tp_enqueueImmediate(ThreadPool *const tp, Task *const task) {
  const char fooName[] = "tp_enqueueImmediate";

  // Argument Validity Check
  errno = 0;
  if (tp == (ThreadPool *)NULL) {
    fprintf(stderr, "argument 'tp' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return errno;
  }

  // obtain lock to update waiting task queue and spawn threads
  errno = pthread_mutex_lock(&tp->taskMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Encountered error while attempting to lock mutex to modify "
            "thread pool's queues in %s\n",
            fooName);
    return errno;
  }

  // Spawn new thread if none are currently available
  if (tp->numIdleThreads == 0) {
    const bool spawned = tp_spawnThread(tp);
    if (!spawned) {
      fprintf(stderr, "Failed spawning new thread pool thread in %s\n",
              fooName);
      return errno; // errno set by tp_spawnThread
    }
  }

  // Add task to queue
  const bool enqueued = q_enqueue(&tp->waitingTasks, &task);
  if (!enqueued) {
    fprintf(stderr,
            "Unable to enqueue new task in thread pool's task queue in %s\n",
            fooName);
    return errno; // errno set by q_enqueue
  }

  // Notify that a task is available in waitingTasks queue
  errno = pthread_cond_signal(&tp->taskAvailable);
  if (errno != 0) {
    fprintf(stderr,
            "Error while signaling a task is available for thread pool in %s\n",
            fooName);
    return errno;
  }

  errno = pthread_mutex_unlock(&tp->taskMutex);
  if (errno != 0) {
    fprintf(stderr,
            "Encountered error while unlocking mutex after modifying "
            "thread pool's queues in %s\n",
            fooName);
  }

  return errno;
}

// ==================== PRIVATE FUNCTIONS ===============
/**
 * @brief function each thread in pool runs to execute tasks
 *
 * @param tp thread pool
 * @return void* errno
 */
void *workerFunction(void *tp) {
  const char fooName[] = "workerFunction";

  // Argument Validity Check
  errno = 0;
  if (tp == (void *)NULL) {
    fprintf(stderr, "argument 'tp' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return (void *)(size_t)errno;
  }

  ThreadPool *tp_ = (ThreadPool *)tp;

  while (true) {
    // Obtain lock to wait for available task
    errno = pthread_mutex_lock(&tp_->taskMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Encountered error while attempting to lock mutex in %s\n",
              fooName);
      break;
    }

    // Wait for task to become available, indicated
    // by taskAvailable condition variable
    while (tp_->running && q_length(&tp_->waitingTasks) == 0) {
      errno = pthread_cond_wait(&tp_->taskAvailable, &tp_->taskMutex);
      if (errno != 0) {
        fprintf(stderr,
                "Encountered error while waiting on task to become available "
                "in %s\n",
                fooName);
        return (void *)(size_t)errno;
      }
    }

    // leave lock held after pthread_cond_wait to modify thread pool

    // exit if forced to quit while idle w/o waiting task
    if (!tp_->running && q_length(&tp_->waitingTasks) == 0) {
      // release lock
      errno = pthread_mutex_unlock(&tp_->taskMutex);
      if (errno != 0) {
        fprintf(stderr,
                "Encountered error while attempting to unlock mutex after "
                "waking idle thread in %s\n",
                fooName);
      }
      break;
    }

    // decrement number of available threads
    --tp_->numIdleThreads;

    // Extract task to run
    const void *const frontT = q_front(&tp_->waitingTasks);
    if (frontT == (void *)NULL) {
      fprintf(
          stderr,
          "Unable to peek front element from queue of waiting tasks in %s\n",
          fooName);
      break; // errno set by q_front
    }
    Task *task = *(Task **)frontT;

    const bool dequeued = q_dequeue(&tp_->waitingTasks);
    if (!dequeued) {
      fprintf(stderr,
              "Unable to remove tasks from queue of waiting tasks in %s\n",
              fooName);
      break; // errno set by q_dequeue
    }

    // release lock after modifying queues
    errno = pthread_mutex_unlock(&tp_->taskMutex);
    if (errno != 0) {
      fprintf(
          stderr,
          "Encountered error while attempting to unlock mutex after modifying "
          "thread pool's queues in %s\n",
          fooName);
      break;
    }

    // Execute extracted task and store result in task
    errno = task_execute(task);
    if (errno != 0) {
      fprintf(stderr, "Failure trying to execute task funciton in %s\n",
              fooName);
      break;
    }

    // Mark Task as completed when it finishes
    errno = task_markCompleted(task);
    if (errno != 0) {
      fprintf(stderr, "Unable to mark task as completed in %s\n", fooName);
      break;
    }

    // Obtain lock to update number of available tasks
    errno = pthread_mutex_lock(&tp_->taskMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Encountered error while attempting to lock mutex to update idle "
              "threads in %s\n",
              fooName);
      break;
    }

    ++tp_->numIdleThreads;

    errno = pthread_mutex_unlock(&tp_->taskMutex);
    if (errno != 0) {
      fprintf(stderr,
              "Encountered error while attempting to unlock mutex after "
              "updating idle threads in %s\n",
              fooName);
      break;
    }
  }

  return (void *)(size_t)errno;
}
/**
 * @file vector.c
 * @author Justen Di Ruscio - (3624673)
 * @brief Provides definitions for basic utilities to operate on arbitrary
 * length, geometrically resized arrays (Vectors)
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include "vector_private.h"
#include <jd/error.h>
#include <jd/string.h>
#include <jd/vector.h>

#include <stdio.h>  // fprintf
#include <stdlib.h> // malloc, realloc
#include <string.h> // memcpy

Vector vector_constructEmpty(const size_t dataSize) {
  Vector vec = {.data = NULL,
                .length = 0,
                .capacity = 0,
                .elementDeleter = NULL,
                .dataSize = dataSize};
  return vec;
}

OptionalVector vector_constructCapacity(const size_t capacity,
                                        const size_t dataSize) {
  const char fooName[] = "vector_constructCapacity";
  Vector vec = {.data = (void *)NULL,
                .length = 0,
                .capacity = capacity,
                .dataSize = dataSize};
  OptionalVector result = {.data = vec, .valid = false};

  // Argument Validity Checks
  errno = 0;
  if (dataSize == 0) {
    fprintf(stderr, "field 'dataSize' of %s must be greater than 0\n", fooName);
    errno = EPERM;
    return result;
  }
  if (capacity == 0) {
    result.data = vec;
    fprintf(stderr, "field 'capacity' of %s must be greather than 0\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Construction
  void *const newVectorBuff = malloc(capacity * dataSize);
  if (newVectorBuff == (void *)NULL) {
    fprintf(stderr,
            "failure allocating memory for vector contents in "
            "%s\n",
            fooName);
    return result; // errno set by malloc
  }
  vec.data = newVectorBuff;
  result.valid = true;
  result.data = vec;
  return result;
}

OptionalVector vector_copyConstruct(const Vector *const other) {
  const char fooName[] = "vector_copyConstruct";
  OptionalVector result = {.valid = false};

  // Argument Validity Check
  errno = 0;
  if (other == (Vector *)NULL) {
    fprintf(stderr,
            "field 'other' of %s must point to a valid "
            "address\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Copy Construct
  Vector vec = {.data = (void *)NULL,
                .length = other->length,
                .capacity = other->capacity,
                .dataSize = other->dataSize};
  void *const newVectorBuff = malloc(vec.capacity * vec.dataSize);
  if (newVectorBuff == (void *)NULL) {
    fprintf(stderr,
            "failure allocating memory for vector contents in "
            "%s\n",
            fooName);
    return result; // errno set by malloc
  }
  vec.data = newVectorBuff;
  memcpy(vec.data, other->data, vec.length * vec.dataSize);

  result.valid = true;
  result.data = vec;
  return result;
}

void vector_freeData(const Vector *const vec) {
  // Return if there's nothing to free
  if (vec == (Vector *)NULL) {
    return;
  }
  // Free data member
  free(vec->data);
}

void vector_freeDataVoid(const void *const vec) {
  // Return if there's nothing to free
  if (vec == (void *)NULL) {
    return;
  }
  // Free data member
  Vector *v = (Vector *)vec;
  vector_freeData(v);
}

void vector_freeElements(const Vector *const vec) {
  // Return if there's nothing to free
  if (vec == (Vector *)NULL || vec->data == (void *)NULL) {
    return;
  }

  for (size_t elementIdx = 0; elementIdx < vec->length; ++elementIdx) {
    const void *const element = vector_at(vec, elementIdx);
    vec->elementDeleter(element);
  }
}

void *vector_at(const Vector *const vec, const size_t index) {
  const char fooName[] = "vector_at";

  // Argument Validity Check
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return (void *)NULL;
  }
  if (vec->length <= index) {
    fprintf(stderr,
            "field 'index' of value %zu in %s is out of bounds of provided "
            "vector of length %zu\n",
            index, fooName, vec->length);
    errno = ENOENT;
    return (void *)NULL;
  }
  // Element Access
  const char *const dataBytes = (char *)vec->data;
  return (void *)(dataBytes + index * vec->dataSize);
}

void *vector_back(const Vector *const vec) {
  const char fooName[] = "vector_back";

  // Argument Validity Check
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return (void *)NULL;
  }

  // Element Access
  if (vec->length == 0) {
    errno = EPERM;
    return (void *)NULL;
  }
  return vector_at(vec, vec->length - 1);
}

bool vector_pushBack(Vector *const vec, const void *const element) {
  const char fooName[] = "vector_pushBack";

  // Argument Validity Checks
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (element == (void *)NULL) {
    fprintf(stderr, "field 'element' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Push Back
  const size_t oldLength = vec->length;
  const bool reserved = vector_reserve(vec, ++vec->length);
  return reserved && vector_assignElement(vec, oldLength, element);
}

bool vector_pushBackAll(Vector *const vec, const size_t numElements,
                        const void *const source) {
  const char fooName[] = "vector_pushBackAll";

  // Argument Validity Checks
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (source == (void *)NULL) {
    fprintf(stderr, "field 'source' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Push Back
  const size_t oldLength = vec->length;
  vec->length += numElements;
  const bool reserved = vector_reserve(vec, vec->length);
  return reserved && vector_assignElements(vec, oldLength, numElements, source);
}

OptionalVector vector_append(const Vector *const vec1,
                             const Vector *const vec2) {
  const char fooName[] = "vector_append";
  OptionalVector result = {.data = vector_constructEmpty(0), .valid = false};

  // Argument Validity Checks
  errno = 0;
  if (vec1 == (Vector *)NULL) {
    fprintf(stderr, "argument 'vec1' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }
  if (vec2 == (Vector *)NULL) {
    fprintf(stderr, "argument 'vec2' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return result;
  }
  if (vec1->dataSize != vec2->dataSize) {
    fprintf(stderr,
            "vectors provided to %s must contain elements of equal size\n",
            fooName);
    errno = EPERM;
    return result;
  }

  // Append Vectors
  Vector both = vector_constructEmpty(vec1->dataSize);
  const bool reserved = vector_reserve(&both, vec1->length + vec2->length);
  if (!reserved) {
    fprintf(stderr, "Failed to reserve vector of %zu elements in %s\n",
            vec1->length + vec2->length, fooName);
    return result; // errno set by vector_reserve
  }

  bool assigned;
  if (vec1->data != NULL) {
    both.length += vec1->length;
    assigned = vector_assignElements(&both, 0, vec1->length, vec1->data);
    if (!assigned) {
      fprintf(stderr, "Failed to assign elements of vec1 in %s\n", fooName);
      return result; // errno set by vector_assignElements
    }
  }
  if (vec2->data != NULL && vec2->length > 0) {
    both.length += vec2->length;
    assigned =
        vector_assignElements(&both, vec1->length, vec2->length, vec2->data);
    if (!assigned) {
      fprintf(stderr, "Failed to assign elements of vec2 in %s\n", fooName);
      return result; // errno set by vector_assignElements
    }
  }

  result.data = both;
  result.valid = true;
  return result;
}

bool vector_reserve(Vector *const vec, const size_t newSize) {
  const char fooName[] = "vector_reserve";

  // Argument Validity Check
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Reserve
  if (newSize > vec->capacity) { // require resize
    const size_t newCapacity = 2 * newSize;
    void *newVectorBuffer = realloc(vec->data, newCapacity * vec->dataSize);
    if (newVectorBuffer == (void *)NULL) { // realloc failed
      fprintf(stderr, "resizing vector buffer with realloc failed in %s\n",
              fooName);
      return false; // realloc sets errno
    }
    vec->data = newVectorBuffer;
    vec->capacity = newCapacity;
  }
  return true;
}

bool vector_clear(Vector *const vec) {
  const char fooName[] = "vector_clear";

  // Argument Validity Check
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Clear Contents
  vec->length = 0;
  return true;
}

bool vector_assignElement(Vector *const vec, const size_t destination,
                          const void *source) {
  const char fooName[] = "vector_assignElement";

  // Argument Validity Checks
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (source == (void *)NULL) {
    fprintf(stderr,
            "field 'source' of %s must point to a "
            "valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  // check for overlaping data
  void *const destinationLocation = vector_at(vec, destination);
  if (errno != 0) {
    fprintf(stderr, "call to vector_at in %s failed. errno = %i: %s\n", fooName,
            errno, strerror(errno));
    return false;
  }
  if (memoryOverlaps(source, destinationLocation, vec->dataSize)) {
    fprintf(stderr,
            "data referenced by fields 'destination' and 'source' of "
            "%s must not overlap\n",
            fooName);
    return false;
  }

  // Assign Element
  return vector_assignElements(vec, destination, 1, source);
}

bool vector_assign(Vector *const destination, const Vector *const source) {
  const char fooName[] = "vector_assign";

  // Argument Validity Checks
  errno = 0;
  if (destination == (Vector *)NULL) {
    fprintf(stderr, "field 'destination' of %s must point to a valid vector\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (source == (Vector *)NULL) {
    fprintf(stderr, "field 'source' of %s must point to a valid vector\n",
            fooName);
    errno = EPERM;
    return false;
  }

  // Assignment
  destination->length = source->length;
  const bool reserved = vector_reserve(destination, source->length);
  if (!reserved) {
    fprintf(stderr, "Unable to reserve memory for destination in %s\n",
            fooName);
    return false; // vector_reserve sets errno
  }
  const bool assigned =
      vector_assignElements(destination, 0, source->length, source->data);
  if (!assigned) {
    fprintf(stderr, "Failure assigning contents in %s\n", fooName);
    return false;
  }

  return true;
}

static bool vector_assignElements(Vector *const vec, const size_t destination,
                                  const size_t numElements,
                                  const void *source) {
  const char fooName[] = "vector_assignElements";

  // Argument Validity Checks
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    return false;
  }
  if (source == (void *)NULL) {
    fprintf(stderr,
            "field 'source' of %s must point to a "
            "valid address\n",
            fooName);
    return false;
  }
  // check for overlaping data
  const size_t numBytes = vec->dataSize * numElements;
  void *const destinationLocation = vector_at(vec, destination);
  if (errno != 0) {
    fprintf(stderr, "call to vector_at in %s failed\n", fooName);
    handleErrorMsg(errno);
    return false;
  }
  if (memoryOverlaps(source, destinationLocation, numBytes)) {
    fprintf(stderr,
            "data referenced by fields 'destination' and 'source' of "
            "%s must not overlap\n",
            fooName);
    return false;
  }

  // Data Assignment
  memcpy(destinationLocation, source, numBytes);
  return true;
}

bool vector_erase(Vector *const vec, const size_t index) {
  const char fooName[] = "vector_erase";

  // Argument Validity Checks
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "field 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return false;
  }
  if (index >= vec->length) {
    fprintf(stderr,
            "field 'index' of %s is out of bounds of the provided vector\n",
            fooName);
    errno = ERANGE;
  }

  // Erase Element
  // create new vector to store elements
  OptionalVector newOpt =
      vector_constructCapacity(vec->capacity, vec->dataSize);
  if (!newOpt.valid) {
    fprintf(stderr,
            "Unable to construct vector in %s to store retained elements\n",
            fooName);
  }
  Vector newVec = newOpt.data;
  newVec.length = vec->length;

  // copy elements up to erasure
  bool assigned = vector_assignElements(&newVec, 0, index, vec->data);
  if (!assigned) {
    fprintf(stderr, "Failure copying first elements in %s\n", fooName);
    return false; // errno set by vector_assignElements
  }

  // copy elements after erasure
  if (vec->length > index + 1) {
    void *source = vector_at(vec, index + 1);
    assigned =
        vector_assignElements(&newVec, index, vec->length - index - 1, source);
    if (!assigned) {
      fprintf(stderr, "Failure copying last elements in %s\n", fooName);
      return false; // errno set by vector_assignElements
    }
  }

  // free old contents
  vector_freeData(vec);

  --newVec.length;
  *vec = newVec;
  return true;
}

ssize_t vector_find(const Vector *const vec, const void *const value) {
  const char fooName[] = "vector_find";
  ssize_t foundIndex = -1;

  // Argument Validity Checks
  errno = 0;
  if (vec == (Vector *)NULL) {
    fprintf(stderr, "argument 'vec' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return foundIndex;
  }
  if (value == (void *)NULL) {
    fprintf(stderr, "argument 'value' of %s must point to a valid address\n",
            fooName);
    errno = EPERM;
    return foundIndex;
  }

  // Find element
  for (unsigned i = 0; i < vec->length; ++i) {
    const void *const vecElem = vector_at(vec, i);
    if (memcmp(vecElem, value, vec->dataSize) == 0) {
      foundIndex = i;
      break;
    }
  }
  return foundIndex;
}
#pragma once
/**
 * @file error.h
 * @author Justen Di Ruscio (3624673)
 * @brief Contains symbols for common error handling/checking functions
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <errno.h>
#include <stdbool.h>

#define ECMDNOTFOUND 127

/**
 * @brief Prints error number and associated Unix error message, from strerror,
 * or a message indicating errorNumber is unknown to strerror
 *
 * @param errorNumber Unix error number
 */
void handleErrorMsg(const int errorNumber);

/**
 * @brief exits the program with provided error number after printing error
 * number and associated Unix error message, from strerror, or a message
 * indicating errorNumber is unknown to strerror
 *
 * @param errorNumber Unix error number
 */
void handleExitError(const int errorNumber);

/**
 * @brief Indicates whether the memory pointed to by first and second overlap or
 * not. Assumes pointed to data is of equal length.
 *
 * @param first pointer to first chunk of memory
 * @param second pointer to second chunk of memory
 * @param dataSize size, in bytes, of both chunks of memory
 * @return true memory overlaps
 * @return false memory doesn't overlap
 */
bool memoryOverlaps(const void* const first, const void* const second,
                    const unsigned dataSize);
#pragma once
/**
 * @file list.h
 * @author Justen Di Ruscio (3624673)
 * @brief Symbols for doubly linked list and functions to modify it.
 * Doesn't use pool allocator but instead allocates each node individually
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <stdbool.h>  // bool, true, false
#include <stddef.h>   // size_t

typedef struct ListNode {
  void *data;
  struct ListNode *next;
  struct ListNode *prev;
} ListNode;

typedef struct List {
  ListNode *head;
  ListNode *tail;
  size_t length;
  size_t dataSize;
  void (*elementDeleter)(void*);
} List;

typedef struct OptionalList {
  List list;
  bool valid;
} OptionalList;

List list_constructEmpty(const size_t dataSize);
OptionalList list_copyConstruct(const List *const other);
void list_freeNodes(List *const list);

ListNode *list_newNode(const size_t dataSize, const void *const element);
void list_freeNode(const List* const list, const ListNode* const);

bool list_containsNode(const List* const list, const ListNode* const node);
ListNode *list_nodeAt(const List* const list, const size_t index);
void *list_elementAt(const List* const list, const size_t index);

bool list_pushFront(List *const list, const void *const element);
bool list_popFront(List *const list);
bool list_pushBack(List *const list, const void *const element);
bool list_pushNodeBack(List* const list, ListNode* const node);
bool list_popBack(List *const list);
bool list_insertAt(List *const list, const size_t index,
                 const void *const element);

bool list_eraseAt(List *const list, const size_t index);
bool list_eraseNode(List *const list, ListNode *const node);
bool list_removeNode(List *const list, ListNode *const node);
/**
 * @file queue.h
 * @author Justen Di Ruscio
 * @brief Declarations for functions related to queue data structure using linked
 * list
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */
#pragma once

#include <jd/list.h>

typedef struct Queue {
  List elements;
} Queue;

Queue q_constructEmpty(const size_t dataSize);
void q_freeElements(Queue* const q);

bool q_enqueue(Queue* const q, const void *const element);
bool q_dequeue(Queue* const q);

void* q_front(const Queue* const q);
void* q_back(const Queue* const q);
size_t q_length(const Queue* const q);
#pragma once
/**
 * @file string.h
 * @author Justen Di Ruscio (3624673)
 * @brief Symbols for arbitrary length, null terminated strings and their
 * manipulation. These Strings are not small-string-optimized.
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <jd/error.h>
#include <jd/vector.h>
#include <string.h>

/**
 * @brief Representation of a string
 *
 */
typedef struct String {
  char* data;
  size_t length;    // in bytes
  size_t capacity;  // memory including null termination
} String;

/**
 * @brief Contains a string and a flag to indicate its validity. Used to return
 * a string and possibly an error from functions.
 *
 */
typedef struct OptionalString {
  String data;
  bool valid;
} OptionalString;

/**
 * @brief Constructs and empty string by initializing the String struct
 *
 * @return String constructed, empty String
 */
String string_constructEmpty();

/**
 * @brief Constructs a String with an initial capacity. Sets errno upon error.
 *
 * @param capacity number of chars to reserve in String's initial capacity
 * @return OptionalString constructed String and flag to indicate validity of
 * the String
 */
OptionalString string_constructCapacity(const size_t capacity);

/**
 * @brief Constructs a String whose contents are copied from the other String.
 * Sets errno upon error.
 *
 * @param other String to copy contents of
 * @return OptionalString constructed string and flag to indicate validity of
 * the String
 */
OptionalString string_copyConstruct(const String* const other);

/**
 * @brief Constructs a String whose contents are copied from the null terminated
 * bytes pointed to by other. Sets errno upon error.
 *
 * @param other c-style string (null-terminated array) to copy contents of
 * @return OptionalString constructed string and flag to indicate validity of
 * the String
 */
OptionalString string_copyConstructChar(const char* const other);

/**
 * @brief Frees the contents of the provided String. Does nothing if the
 * provided String or its contents is NULL.
 *
 * @param str String to free contents of
 */
void string_freeData(const String* const str);

/**
 * @brief Calls string_freeData after casting str to a String. Provides a
 * uniform interface for freeing String data.
 *
 * @param str String to free contents of
 */
void string_freeDataVoid(const void* const str);

/**
 * @brief Reserves enough memory in str to contain newCapacity chars. Does
 * nothing if str is already large enough. Sets errno upon error.
 *
 * @param newCapacity number of chars str's buffer should hold after reserve
 * @return true successfully reserved memory
 * @return false failed to reserve memory
 */
bool string_reserve(String* const str, const size_t newCapacity);

/**
 * @brief Splits the provided string by any of the delimeters pointed to by
 * delim into a Vector of Strings. Resulting Strings own their memory; they
 * don't point to contents of str. Sets errno upon error.
 *
 * @param str String to split
 * @param delim null-terminated list of chars used as delimeters to split str
 * @return OptionalVector Vector of split Strings and a flag do indicate the
 * validity of the operations.
 */
OptionalVector string_split(const String* const str, const char* const delim);

/**
 * @brief Compares contents of two strings with strcmp
 *
 * @param first String
 * @param second String
 * @return int result of strcmp
 */
int string_compare(const String* const first, const String* const second);

/**
 * @brief Compares contents of first String with null-terminated c-style
 * string, second using strcmp.
 *
 * @param first String
 * @param second null-terminated c-style string
 * @return int result of strcmp
 */
int string_compareChar(const String* const first, const char* const second);

/**
 * @brief Indicates if the provided String's contents contains the provided
 * char. Sets errno upon error.
 *
 * @param string String to find char in
 * @param element char to find in string
 * @return true element is present in string
 * @return false element is not present in string
 */
bool string_contains(const String* const string, const char element);

/**
 * @brief Strips any of the chars in delimeters from the start and end of
 * string. Leaves string unmodified. Sets errno upon error
 *
 * @param string String to strip characters from
 * @param delimeters String containing chars to strip from string
 * @return OptionalString stripped string and flag to indicate the validity of
 * the operations.
 */
OptionalString string_strip(const String* const string,
                            const String* const delimeters);
#pragma once
/**
 * @file task.h
 * @author Justen Di Ruscio
 * @brief Declarations of Task abstraction
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>
#include <stdbool.h>

// Encapsulates a packaged task and a future but can also encapsulate a promise
// and a future if foo does nothing, because the task is marked completed
// independently of running foo
typedef struct Task {
  void *(*foo)(void *);
  void *fooArg;
  void **fooReturn;
  int fooErrno;
  bool completed;
  pthread_cond_t completedCond;
  pthread_mutex_t completedMutex;
} Task;


int task_init(Task *const task, void *(*foo)(void *), void *fooArg,
                void **fooReturn);

int task_destroy(Task *const task);

/**
 * @brief executes foo with fooArg but doesn't mark task completed
 *
 * @param task
 * @return int
 */
int task_execute(Task* const task);

/**
 * @brief Marks the task as completed through completed, completedCond and completedMutex
 *
 * @param task task to mark completed
 * @return int errno
 */
int task_markCompleted(Task*const task);

/**
 * @brief Blocks until foo completes and places result of foo in fooReturn
 *
 * @param task
 * @return int
 */
int task_getResult(Task *const task);
#pragma once
/**
 * @file threadpool.h
 * @author Justen Di Ruscio
 * @brief Declarations for an expanding threadpool
 * @version 0.1
 * @date 2021-03-20
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <pthread.h>
#include <stdbool.h>

#include <jd/queue.h>
#include <jd/task.h>


// the number of idle threads in threads are tacked such that enqueueImmediate
// can immediately spawn a new thread if no idle threads are available. This is
// to meet the requirements in the assignment, where multiple specific items
// require their own thread, like each caterpillar. A normal thread pool
// wouldn't have this functionality, but it's part of the assignment.

typedef struct ThreadPool {
  Queue threads;
  unsigned numIdleThreads;
  pthread_cond_t taskAvailable;
  pthread_mutex_t taskMutex;
  Queue waitingTasks;
  bool running;
} ThreadPool;

/**
 * @brief initializes the thread pool. Non-re-entrant. errno set on error
 *
 * @param tp threadpool to initialize
 * @param numInitThreads num thread to start thread pool with
 * @return int errno
 */
int tp_init(ThreadPool *const tp, const unsigned numInitThreads);

/**
 * @brief destroys provided thread pool. errno set of error
 *
 * @param tp thread pool
 * @return true success
 * @return false fail
 */
bool tp_destroy(ThreadPool *const tp);

/**
 * @brief enqueues the provided task into the threadpool, running it immediately by spawning a therad if one is not available, thereby expanding the pool of threads by one
 *
 * @param tp thread pool
 * @param task task to enqueue
 * @return int errno
 */
int tp_enqueueImmediate(ThreadPool *const tp, Task *const task);
#pragma once
/**
 * @file vector.h
 * @author Justen Di Ruscio - (3624673)
 * @brief Provides symbols for basic utilities to operate on arbitrary length,
 * geometrically resized arrays (Vectors)
 * @version 0.1
 * @date 2021-02-16
 *
 * @copyright Copyright (c) 2021
 *
 */

#include <stdbool.h>    // bool, true, false
#include <stddef.h>     // size_t
#include <sys/types.h>  // ssize_t

/**
 * @brief Represents a vector
 *
 */
typedef struct Vector {
  void* data;
  size_t length;    // num. elements
  size_t capacity;  // num. possible elements
  size_t dataSize;  // size of each element (bytes)
  void (*elementDeleter)(
      const void* const element);  // function to free element
} Vector;

/**
 * @brief Used to return a vector and a flag representing if the vector is valid
 * from functions that return a vector and a possible error.
 *
 */
typedef struct OptionalVector {
  Vector data;
  bool valid;
} OptionalVector;

/**
 * @brief Creates a completely empty vector by initializing the Vector struct
 *
 * @param dataSize size of elements contained by the vector to construct
 * @return Vector constructed, empty Vector
 */
Vector vector_constructEmpty(const size_t dataSize);

/**
 * @brief Creates a vector with an initial capacity, allocated on the heap. Sets
 * errno if result is invalid
 *
 * @param capacity amount of memory to initially allocate in number of elements
 * @param dataSize size of elements contained by the vector to construct
 * @return OptionalVector contains the constructed vector and a flag to indicate
 * its validity
 */
OptionalVector vector_constructCapacity(const size_t capacity,
                                        const size_t dataSize);

/**
 * @brief Creates a new vector with contents allocated on the heap and with the
 * same elements as other. Sets errno if result is invalid
 *
 * @param other another vector to copy elements from. Left unmodified
 * @return OptionalVector contains the constructed vector and a flag to indicate
 * its validity
 */
OptionalVector vector_copyConstruct(const Vector* const other);

/**
 * @brief Frees the contents of the provided vector. Returns NULL and performs
 * no action if vec is NULL or vec->data is NULL
 *
 * @param vec Vector who's contents were allocated on the heap
 */
void vector_freeData(const Vector* const vec);

/**
 * @brief Calls vector_freeData after casting vec to a Vector*. Used to provide
 * a generic interface.
 *
 * @param vec a pointer pointing to a Vector
 */
void vector_freeDataVoid(const void* const vec);

/**
 * @brief Applies vector->elementDeleter to each element in the Vector's data
 * contents. Used if the elements are/contain heap allocated data
 *
 * @param vec Vector to free elements of
 */
void vector_freeElements(const Vector* const vec);

/**
 * @brief Returns a pointer to the element at index or NULL if an error
 * occurred. errno set upon error, like under an out of bounds condition
 *
 * @param vec Vector to access element of
 * @param index index of element in vec to access
 * @return void* pointer to contained element
 */
void* vector_at(const Vector* const vec, const size_t index);

/**
 * @brief Accesses the last element of vec by calling vector_at. Sets errno on
 * error and returns NULL, like if the vector is empty.
 *
 * @param vec Vector to access last element of
 * @return void*
 */
void* vector_back(const Vector* const vec);

/**
 * @brief Assigns the value of the vec's element at index destination to the
 * value pointed to by source. Copies dereferenced data, not source itself. Sets
 * errno upon error and returns false to indicate error.
 *
 * @param vec Vector to assign element of
 * @param destination index of element in vec to assign
 * @param source pointer to data to assign to element at destination
 * @return true successfully assigned element
 * @return false failed to assign element
 */
bool vector_assignElement(Vector* const vec, const size_t destination,
                          const void* source);

/**
 * @brief Copy assigns contents of vector source to destination. Sets errno upon
 * error and reserves memory in destination if its capacity is too small
 *
 * @param destination Vector with contents to copy
 * @param source Vector who's contents will be assigned
 * @return true successfully assigned contents
 * @return false failed to assign contents
 */
bool vector_assign(Vector* const destination, const Vector* const source);

/**
 * @brief Adds another element to the end of vec with the contents pointed to by
 * element. Sets errno upon error.
 *
 * @param vec Vector to extend
 * @param element pointer to data to copy into added element
 * @return true successfully pushed new element onto vec
 * @return false failed to push new element onto vec
 */
bool vector_pushBack(Vector* const vec, const void* const element);

/**
 * @brief Adds all the contiguous elements pointed to by elements as new
 * elements on the end of vec. Sets errno upon error.
 *
 * @param vec Vector to extend
 * @param numElements number of elements pointed to by elements and to extend
 * vec by
 * @param elements contiguous array of elements to copy to vec
 * @return true successfully pushed new elements onto vec
 * @return false failed to push new elements onto vec
 */
bool vector_pushBackAll(Vector* const vec, const size_t numElements,
                        const void* const elements);

/**
 * @brief Constructs a new vector whose contents is a concatenation of the
 * contents of vec1 and vec2. Sets errno on error. Appends nothing if either
 * provided vector has no data contents.
 *
 * @param vec1 first Vector
 * @param vec2 second Vector, appended to vec1
 * @return OptionalVector contains concatenated vector and flag to indicate
 * validity of result.
 */
OptionalVector vector_append(const Vector* const vec1,
                             const Vector* const vec2);

/**
 * @brief Reserves enough capacity in vec to contain newSize number of elements.
 * Does nothing if vec is already large enough. Sets errno upon error.
 *
 * @param vec Vector upon which data is reserved
 * @param newSize number of elements vec should hold after reservation
 * @return true successfully reserved memory
 * @return false failed to reserve memory
 */
bool vector_reserve(Vector* const vec, const size_t newSize);

/**
 * @brief Clears contents of provided vector. Doesn't free any memory, only
 * resizes it to 0. Sets errno upon error.
 *
 * @param vec Vector to clear
 * @return true successfully cleared vector
 * @return false failed to clear provided vector
 */
bool vector_clear(Vector* const vec);

/**
 * @brief Erases the element of vec at index by copying other elements to a new
 * Vector. Frees original array but doesn't free elements if they are heap
 * allocated. Sets errno upon error.
 *
 * @param vec Vector to erase element of
 * @param index index of element in vec to erase
 * @return true successfully erased element
 * @return false failed to erase element
 */
bool vector_erase(Vector* const vec, const size_t index);

/**
 * @brief Returns index of element in vec with same data as that pointed to by
 * value. Compares dereferenced data, not addresses. Returns -1 upon failure or
 * error, where errno is set upon error.
 *
 * @param vec Vector to find element in
 * @param value value of element to find
 * @return ssize_t index of found element or -1 upon failure
 */
ssize_t vector_find(const Vector* const vec, const void* const value);
